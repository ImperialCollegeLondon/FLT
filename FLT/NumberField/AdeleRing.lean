import Mathlib
import FLT.DedekindDomain.FiniteAdeleRing.BaseChange
import FLT.Mathlib.NumberTheory.NumberField.Basic
import FLT.Mathlib.RingTheory.TensorProduct.Pi
import FLT.Mathlib.Topology.Algebra.ContinuousAlgEquiv
import FLT.Mathlib.Topology.Algebra.Group.Quotient
import FLT.NumberField.InfiniteAdeleRing

open scoped TensorProduct

universe u

open NumberField

section LocallyCompact

-- see https://github.com/smmercuri/adele-ring_locally-compact
-- for a proof of this

variable (K : Type*) [Field K] [NumberField K]

instance NumberField.AdeleRing.locallyCompactSpace : LocallyCompactSpace (AdeleRing (ùìû K) K) :=
  sorry -- issue #253

end LocallyCompact

section Discrete

open DedekindDomain

theorem Rat.AdeleRing.zero_discrete : ‚àÉ U : Set (AdeleRing (ùìû ‚Ñö) ‚Ñö),
    IsOpen U ‚àß (algebraMap ‚Ñö (AdeleRing (ùìû ‚Ñö) ‚Ñö)) ‚Åª¬π' U = {0} := by
  use {f | ‚àÄ v, f v ‚àà (Metric.ball 0 1)} √óÀ¢
    {f | ‚àÄ v , f v ‚àà IsDedekindDomain.HeightOneSpectrum.adicCompletionIntegers ‚Ñö v}
  refine ‚ü®?_, ?_‚ü©
  ¬∑ dsimp
    sorry -- issue #252 -- should be easy (product of opens is open, product of integers is surely
          -- known to be open)
  ¬∑ apply subset_antisymm
    ¬∑ intro x hx
      rw [Set.mem_preimage] at hx
      simp only [Set.mem_singleton_iff]
      have : (algebraMap ‚Ñö (AdeleRing (ùìû ‚Ñö) ‚Ñö)) x =
        (algebraMap ‚Ñö (InfiniteAdeleRing ‚Ñö) x, algebraMap ‚Ñö (FiniteAdeleRing (ùìû ‚Ñö) ‚Ñö) x)
      ¬∑ rfl
      rw [this] at hx
      clear this
      rw [Set.mem_prod] at hx
      obtain ‚ü®h1, h2‚ü© := hx
      dsimp only at h1 h2
      simp only [Metric.mem_ball, dist_zero_right, Set.mem_setOf_eq,
        InfiniteAdeleRing.algebraMap_apply, UniformSpace.Completion.norm_coe] at h1
      simp only [Set.mem_setOf_eq] at h2
      specialize h1 Rat.infinitePlace
      change ‚Äñ(x : ‚ÑÇ)‚Äñ < 1 at h1
      simp at h1
      have intx: ‚àÉ (y:‚Ñ§), y = x
      ¬∑ obtain ‚ü®z, hz‚ü© := IsDedekindDomain.HeightOneSpectrum.mem_integers_of_valuation_le_one
            ‚Ñö x <| fun v ‚Ü¶ by
          specialize h2 v
          letI : UniformSpace ‚Ñö := v.adicValued.toUniformSpace
          rw [IsDedekindDomain.HeightOneSpectrum.mem_adicCompletionIntegers] at h2
          rwa [‚Üê IsDedekindDomain.HeightOneSpectrum.valuedAdicCompletion_eq_valuation']
        use Rat.ringOfIntegersEquiv z
        rw [‚Üê hz]
        apply Rat.ringOfIntegersEquiv_eq_algebraMap
      obtain ‚ü®y, rfl‚ü© := intx
      simp only [abs_lt] at h1
      norm_cast at h1 ‚ä¢
      -- We need the next line because `norm_cast` is for some reason producing a `negSucc 0`.
      -- I haven't been able to isolate this behaviour even in a standalone lemma.
      -- We could also make `omega` more robust against accidental appearances of `negSucc`.
      rw [Int.negSucc_eq] at h1
      omega
    ¬∑ intro x
      simp only [Set.mem_singleton_iff, Set.mem_preimage]
      rintro rfl
      simp only [map_zero]
      change (0, 0) ‚àà _
      simp only [Prod.mk_zero_zero, Set.mem_prod, Prod.fst_zero, Prod.snd_zero]
      constructor
      ¬∑ simp only [Metric.mem_ball, dist_zero_right, Set.mem_setOf_eq]
        intro v
        have : ‚Äñ(0:InfiniteAdeleRing ‚Ñö) v‚Äñ = 0
        ¬∑ simp only [norm_eq_zero]
          rfl
        simp [this, zero_lt_one]
      ¬∑ simp only [Set.mem_setOf_eq]
        intro v
        apply zero_mem

-- Maybe this discreteness isn't even stated in the best way?
-- I'm ambivalent about how it's stated
open Pointwise in
theorem Rat.AdeleRing.discrete : ‚àÄ q : ‚Ñö, ‚àÉ U : Set (AdeleRing (ùìû ‚Ñö) ‚Ñö),
    IsOpen U ‚àß (algebraMap ‚Ñö (AdeleRing (ùìû ‚Ñö) ‚Ñö)) ‚Åª¬π' U = {q} := by
  obtain ‚ü®V, hV, hV0‚ü© := zero_discrete
  intro q
  set Œπ  := algebraMap ‚Ñö (AdeleRing (ùìû ‚Ñö) ‚Ñö)    with hŒπ
  set q‚Çê := Œπ q                           with hq‚Çê
  set f  := Homeomorph.subLeft q‚Çê         with hf
  use f ‚Åª¬π' V, f.isOpen_preimage.mpr hV
  have : f ‚àò Œπ = Œπ ‚àò Homeomorph.subLeft q := by ext; simp [hf, hq‚Çê]
  rw [‚Üê Set.preimage_comp, this, Set.preimage_comp, hV0]
  ext
  simp only [Set.mem_preimage, Homeomorph.subLeft_apply, Set.mem_singleton_iff, sub_eq_zero, eq_comm]

variable (K : Type*) [Field K] [NumberField K]

theorem NumberField.AdeleRing.discrete : ‚àÄ k : K, ‚àÉ U : Set (AdeleRing (ùìû K) K),
    IsOpen U ‚àß (algebraMap K (AdeleRing (ùìû K) K)) ‚Åª¬π' U = {k} := sorry -- issue #257

end Discrete

section BaseChange

variable (K L : Type*) [Field K] [NumberField K] [Field L] [NumberField L] [Algebra K L]

open NumberField

variable [Algebra K (AdeleRing (ùìû L) L)] [IsScalarTower K L (AdeleRing (ùìû L) L)]

/-- The canonical map from the adeles of K to the adeles of L -/
noncomputable def NumberField.AdeleRing.baseChange :
    AdeleRing (ùìû K) K ‚ÜíA[K] AdeleRing (ùìû L) L :=
  sorry -- product of finite and infinite adele maps

open scoped TensorProduct

noncomputable instance : Algebra (AdeleRing (ùìû K) K) (L ‚äó[K] AdeleRing (ùìû K) K) :=
  Algebra.TensorProduct.rightAlgebra

instance : TopologicalSpace (L ‚äó[K] AdeleRing (ùìû K) K) :=
  moduleTopology (AdeleRing (ùìû K) K) (L ‚äó[K] AdeleRing (ùìû K) K)

instance i' : IsModuleTopology (AdeleRing (ùìû K) K) (L ‚äó[K] AdeleRing (ùìû K) K) := ‚ü®rfl‚ü©

/-- The canonical `L`-algebra isomorphism from `L ‚äó_K K_‚àû` to `L_‚àû` induced by the
`K`-algebra base change map `K_‚àû ‚Üí L_‚àû`. -/
def NumberField.AdeleRing.baseChangeEquiv :
    (L ‚äó[K] (AdeleRing (ùìû K) K)) ‚âÉA[L] AdeleRing (ùìû L) L :=
  sorry

variable {L}

theorem NumberField.AdeleRing.baseChangeEquiv_tsum_apply_right (l : L) :
  baseChangeEquiv K L (l ‚äó‚Çú[K] 1) = algebraMap L (AdeleRing (ùìû L) L) l := sorry

variable (L)

-- TODO: Move this stuff
noncomputable def Module.Finite.equivPi (R M : Type*) [Ring R] [StrongRankCondition R]
    [AddCommGroup M] [Module R M] [Module.Free R M] [Module.Finite R M] :
    M ‚âÉ‚Çó[R] Fin (Module.finrank R M) ‚Üí R :=
  LinearEquiv.ofFinrankEq _ _ <| by rw [Module.finrank_pi, Fintype.card_fin]

variable (R M N : Type*) [CommRing R] [AddCommMonoid N]
    [Semiring M] [Module R N] [Module R M] [Module.Free R M] [Module.Finite R M]

-- Need to turn this into an N-linear map
noncomputable abbrev TensorProduct.finiteEquivPi (R M N : Type*) [CommRing R] [AddCommMonoid N]
    [AddCommGroup M] [Module R N] [Module R M] [Module.Free R M] [Module.Finite R M]
    [StrongRankCondition R] :
    M ‚äó[R] N ‚âÉ‚Çó[R] Fin (Module.finrank R M) ‚Üí N :=
  (TensorProduct.comm _ _ _).trans <|
    (TensorProduct.congr (LinearEquiv.refl R N) (Module.Finite.equivPi _ _)).trans
      (TensorProduct.piScalarRight _ _ _ _)

noncomputable abbrev TensorProduct.finiteEquivPiRight (R M N : Type*) [CommRing R] [CommSemiring N]
    [CommRing M] [Algebra R N] [Algebra R M] [Module.Free R M] [Module.Finite R M]
    [StrongRankCondition R] :
    N ‚äó[R] M ‚âÉ‚Çó[N] Fin (Module.finrank R M) ‚Üí N :=
  (TensorProduct.AlgebraTensorModule.congr (LinearEquiv.refl N N) (Module.Finite.equivPi _ _)).trans
    (TensorProduct.piScalarRight _ _ _ _)

theorem Fintype.sum_pi_single_pi {Œ± : Type*} {Œ≤ : Œ± ‚Üí Type*} [DecidableEq Œ±] [Fintype Œ±]
    [(a : Œ±) ‚Üí AddCommMonoid (Œ≤ a)] (f : (a : Œ±) ‚Üí Œ≤ a) :
    ‚àë (a : Œ±), Pi.single a (f a) = f := by
  simp_rw [funext_iff, Fintype.sum_apply]
  exact fun _ => Fintype.sum_pi_single _ _

theorem TensorProduct.finiteEquivPi_symm_apply (R M N : Type*) [Field R] [CommSemiring N]
    [AddCommGroup M] [Algebra R N] [Module R M] [FiniteDimensional R M]
    (x : Fin (Module.finrank R M) ‚Üí R) :
    (finiteEquivPi R M N).symm (fun i => algebraMap _ _ (x i)) =
      (Module.Finite.equivPi R M).symm x ‚äó‚Çú[R] 1 := by
  simp [Algebra.TensorProduct.piScalarRight_symm_apply_of_algebraMap, Fintype.sum_pi_single_pi]

theorem TensorProduct.finiteEquivPiRight_symm_apply (R M N : Type*) [Field R] [CommSemiring N]
    [CommRing M] [Algebra R N] [Algebra R M] [FiniteDimensional R M]
    (x : Fin (Module.finrank R M) ‚Üí R) :
    (finiteEquivPiRight R M N).symm (fun i => algebraMap _ _ (x i)) =
      1 ‚äó‚Çú[R] (Module.Finite.equivPi R M).symm x := by
  simp [Algebra.TensorProduct.piScalarRight_symm_apply_of_algebraMap, Fintype.sum_pi_single_pi]

namespace NumberField.AdeleRing

variable (K L : Type*) [Field K] [Field L] [NumberField K] [NumberField L] [Algebra K L]

noncomputable instance : Algebra K (NumberField.AdeleRing (ùìû L) L) :=
  Algebra.compHom _ (algebraMap K L)

def IsModuleTopology.continuousLinearEquiv {A B R : Type*} [TopologicalSpace A]
    [TopologicalSpace B] [TopologicalSpace R] [Semiring R] [AddCommMonoid A] [AddCommMonoid B]
    [Module R A] [Module R B] [IsModuleTopology R A] [IsModuleTopology R B]
    (e : A ‚âÉ‚Çó[R] B) :
    A ‚âÉL[R] B where
  __ := e
  continuous_toFun :=
    letI := IsModuleTopology.toContinuousAdd
    IsModuleTopology.continuous_of_linearMap e.toLinearMap
  continuous_invFun :=
    letI := IsModuleTopology.toContinuousAdd
    IsModuleTopology.continuous_of_linearMap e.symm.toLinearMap

def IsModuleTopology.continuousAlgEquiv {A B R : Type*} [TopologicalSpace A] [TopologicalSpace R]
    [TopologicalSpace B] [CommSemiring R]  [CommSemiring A] [CommSemiring B]
    [Algebra R A] [Algebra R B]  [IsModuleTopology R A] (e : A ‚âÉ‚Çê[R] B)
    [IsModuleTopology R B] :
    A ‚âÉA[R] B where
  toAlgEquiv := e
  continuous_toFun :=
    letI := IsModuleTopology.toContinuousAdd
    IsModuleTopology.continuous_of_linearMap e.toLinearMap
  continuous_invFun :=
    letI := IsModuleTopology.toContinuousAdd
    IsModuleTopology.continuous_of_linearMap e.symm.toLinearMap

@[simp]
theorem IsModuleTopology.continuousLinearEquiv_symm_apply {A B R : Type*} [TopologicalSpace A]
    [TopologicalSpace B] [TopologicalSpace R] [Semiring R] [AddCommMonoid A] [AddCommMonoid B]
    [Module R A] [Module R B] [IsModuleTopology R A] [IsModuleTopology R B]
    (e : A ‚âÉ‚Çó[R] B) (b : B) :
    (continuousLinearEquiv e).symm b = e.symm b := rfl


instance instPiIsModuleTopology : IsModuleTopology (AdeleRing (ùìû K) K) (Fin (Module.finrank K L) ‚Üí AdeleRing (ùìû K) K) :=
  IsModuleTopology.instPi

instance : IsScalarTower K L (AdeleRing (ùìû L) L) :=
  IsScalarTower.of_algebraMap_eq' rfl

instance : TopologicalSpace (AdeleRing (ùìû K) K ‚äó[K] L) :=
  moduleTopology (AdeleRing (ùìû K) K) (AdeleRing (ùìû K) K ‚äó[K] L)

instance : IsModuleTopology (AdeleRing (ùìû K) K) (AdeleRing (ùìû K) K ‚äó[K] L)  := by
  exact ‚ü®rfl‚ü©

noncomputable def comm' (A R B : Type*) [CommSemiring A] [CommSemiring B] [CommSemiring R] [Algebra R A] [Algebra R B] :
    letI : Algebra A (B ‚äó[R] A) := Algebra.TensorProduct.rightAlgebra
    A ‚äó[R] B ‚âÉ‚Çó[A] B ‚äó[R] A where
  __ : Algebra A (B ‚äó[R] A) := Algebra.TensorProduct.rightAlgebra
  toFun := Algebra.TensorProduct.comm R A B |>.toFun
  invFun := Algebra.TensorProduct.comm R A B |>.invFun
  map_add' := Algebra.TensorProduct.comm R A B |>.map_add'
  left_inv := Algebra.TensorProduct.comm R A B |>.left_inv
  right_inv := Algebra.TensorProduct.comm R A B |>.right_inv
  map_smul' a x := by
    simp
    induction' x using TensorProduct.induction_on
    ¬∑ simp
    ¬∑ simp only [TensorProduct.smul_tmul']
      simp only [Algebra.TensorProduct.comm_tmul]
      rw [RingHom.smul_toAlgebra']
      simp
    ¬∑ rw [RingHom.smul_toAlgebra']
      simp
      simp_rw [Algebra.smul_def]
      simp
      rw [mul_add]

noncomputable abbrev tensorProductContinuousLinearEquivPi :
    L ‚äó[K] AdeleRing (ùìû K) K ‚âÉL[K] (Fin (Module.finrank K L) ‚Üí AdeleRing (ùìû K) K) :=
  letI := instPiIsModuleTopology K L
  IsModuleTopology.continuousLinearEquiv ((comm' _ _ _).symm.trans <|
    TensorProduct.finiteEquivPiRight K L (AdeleRing (ùìû K) K)) |>.restrictScalars K

noncomputable abbrev baseChangePi :
    (Fin (Module.finrank K L) ‚Üí AdeleRing (ùìû K) K) ‚âÉL[K] AdeleRing (ùìû L) L :=
  (tensorProductContinuousLinearEquivPi K L).symm.trans
    ((baseChangeEquiv K L).restrictScalars K).toContinuousLinearEquiv

variable {K L}

@[simp]
theorem TensorProduct.AlgebraTensorModule.congr_symm_apply {R A M N P Q : Type*} [CommSemiring R]
    [Semiring A] [Algebra R A] [AddCommMonoid M] [Module R M] [Module A M] [IsScalarTower R A M]
    [AddCommMonoid N] [Module R N] [AddCommMonoid P] [Module R P] [Module A P] [IsScalarTower R A P]
    [AddCommMonoid Q] [Module R Q] [IsScalarTower R A M] [IsScalarTower R A P] (f : M ‚âÉ‚Çó[A] P) (g : N ‚âÉ‚Çó[R] Q) (x : P ‚äó[R] Q) :
    (TensorProduct.AlgebraTensorModule.congr f g).symm x = TensorProduct.AlgebraTensorModule.map (A := A) f.symm g.symm x := rfl

theorem baseChangePi_apply_of_algebraMap
    {x : Fin (Module.finrank K L) ‚Üí AdeleRing (ùìû K) K}
    {y : Fin (Module.finrank K L) ‚Üí K}
    (h : ‚àÄ i, algebraMap K (AdeleRing (ùìû K) K) (y i) = x i) :
    baseChangePi K L x = algebraMap L _ (Module.Finite.equivPi _ _ |>.symm y) := by
  rw [‚Üê funext h, ContinuousLinearEquiv.trans_apply,
    ContinuousLinearEquiv.restrictScalars_symm_apply, ContinuousAlgEquiv.coe_restrictScalars_apply,
    LinearEquiv.restrictScalars_apply, ContinuousLinearEquiv.coe_toLinearEquiv]
  simp only [IsModuleTopology.continuousLinearEquiv]
  rw [LinearEquiv.trans_symm, LinearEquiv.symm_symm, LinearEquiv.trans_apply]
  rw [TensorProduct.finiteEquivPiRight_symm_apply]
  simp [comm']
  rw [ContinuousAlgEquiv.toContinuousLinearEquiv_apply,
    baseChangeEquiv_tsum_apply_right]

theorem baseChangePi_mem_principalSubgroup
    {x : Fin (Module.finrank K L) ‚Üí AdeleRing (ùìû K) K}
    (h : x ‚àà AddSubgroup.pi Set.univ (fun _ => principalSubgroup (ùìû K) K)) :
    baseChangePi K L x ‚àà principalSubgroup (ùìû L) L := by
  simp only [AddSubgroup.mem_pi, Set.mem_univ, forall_const] at h
  choose y hy using h
  exact baseChangePi_apply_of_algebraMap hy ‚ñ∏ ‚ü®Module.Finite.equivPi _ _ |>.symm y, rfl‚ü©

variable (K L)

theorem baseChangePi_map_principalSubgroup :
    (AddSubgroup.pi Set.univ (fun (_ : Fin (Module.finrank K L)) => principalSubgroup (ùìû K) K)).map
      (baseChangePi K L).toAddMonoidHom = principalSubgroup (ùìû L) L := by
  ext x
  simp only [AddSubgroup.mem_map, LinearMap.toAddMonoidHom_coe, LinearEquiv.coe_coe,
    ContinuousLinearEquiv.coe_toLinearEquiv]
  refine ‚ü®fun ‚ü®a, h, ha‚ü© => ha ‚ñ∏ baseChangePi_mem_principalSubgroup h, ?_‚ü©
  rintro ‚ü®a, rfl‚ü©
  use fun i => algebraMap K (AdeleRing (ùìû K) K) (Module.Finite.equivPi _ _ a i)
  refine ‚ü®fun i _ => ‚ü®Module.Finite.equivPi _ _ a i, rfl‚ü©, ?_‚ü©
  rw [baseChangePi_apply_of_algebraMap (fun i => rfl), LinearEquiv.symm_apply_apply]

noncomputable def baseChangeQuotientPi :
    (Fin (Module.finrank K L) ‚Üí AdeleRing (ùìû K) K ‚ß∏ principalSubgroup (ùìû K) K) ‚âÉ‚Çú+
      AdeleRing (ùìû L) L ‚ß∏ principalSubgroup (ùìû L) L :=
  (ContinuousAddEquiv.quotientPi _).symm.trans <|
    QuotientAddGroup.continuousAddEquiv _ _ _ _ (baseChangePi K L).toContinuousAddEquiv
      (baseChangePi_map_principalSubgroup K L)

end NumberField.AdeleRing

end BaseChange

section Compact

open NumberField

theorem Rat.AdeleRing.cocompact :
    CompactSpace (AdeleRing (ùìû ‚Ñö) ‚Ñö ‚ß∏ AdeleRing.principalSubgroup (ùìû ‚Ñö) ‚Ñö) :=
  sorry -- issue #258

variable (K L : Type*) [Field K] [Field L] [NumberField K] [NumberField L] [Algebra K L]

theorem NumberField.AdeleRing.cocompact :
    CompactSpace (AdeleRing (ùìû K) K ‚ß∏ AdeleRing.principalSubgroup (ùìû K) K) :=
  letI := Rat.AdeleRing.cocompact
  (baseChangeQuotientPi ‚Ñö K).compactSpace

end Compact
