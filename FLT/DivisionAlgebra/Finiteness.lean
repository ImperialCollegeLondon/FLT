/-
Copyright (c) 2024 Kevin Buzzard. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Kevin Buzzard, Ludwig Monnerjahn, Hannah Scholz
-/
import Mathlib.NumberTheory.NumberField.Basic
import Mathlib.RingTheory.DedekindDomain.FiniteAdeleRing
import Mathlib.Algebra.Group.Subgroup.Pointwise
import FLT.Mathlib.Topology.Algebra.Module.ModuleTopology
import Mathlib.GroupTheory.DoubleCoset
import Mathlib.Algebra.Central.Defs
import Mathlib.Tactic.LinearCombination'
import FLT.NumberField.AdeleRing
import FLT.HaarMeasure.HaarChar.Ring
import FLT.HaarMeasure.HaarChar.AdeleRing

/-

# Fujisaki's lemma

We prove a lemma which Voight (in his quaternion algebra book) attributes to Fujisaki:
if `D` is a finite-dimensional division algebra over a number field `K`
and if `U Ріє (D РіЌ[K] ­ЮћИ_K^infty)╦Б` is a compact open subgroup then the double coset
space `D╦Б \ (D РіЌ[K] ­ЮћИ_K^infty)╦Б / U` is finite.

-/

suppress_compilation

open IsDedekindDomain MeasureTheory

open scoped NumberField TensorProduct

variable (K : Type*) [Field K] [NumberField K]
variable (D : Type*) [DivisionRing D] [Algebra K D] [FiniteDimensional K D]

namespace NumberField.AdeleRing.DivisionAlgebra

set_option quotPrecheck false in
/-- `D_­ЮћИ` is notation for `D РіЌ[K] ­ЮћИ_K`. -/
notation "D_­ЮћИ" => (D РіЌ[K] AdeleRing (­ЮЊъ K) K)

instance : Algebra (AdeleRing (­ЮЊъ K) K) D_­ЮћИ :=
  Algebra.TensorProduct.rightAlgebra

-- Ruben did this somewhere TODO
instance : Module.Finite (AdeleRing (­ЮЊъ K) K) D_­ЮћИ := sorry

/-- The module topology on `D_­ЮћИ`. -/
local instance : TopologicalSpace D_­ЮћИ :=
  moduleTopology (AdeleRing (­ЮЊъ K) K) _

local instance : IsModuleTopology (AdeleRing (­ЮЊъ K) K) D_­ЮћИ := РЪеrflРЪЕ

local instance : IsTopologicalRing D_­ЮћИ :=
  IsModuleTopology.Module.topologicalRing (AdeleRing (­ЮЊъ K) K) _

local instance : LocallyCompactSpace D_­ЮћИ := sorry -- we have this (unfinished) elsewhere TODO

variable [MeasurableSpace (D РіЌ[K] AdeleRing (­ЮЊъ K) K)] [BorelSpace (D РіЌ[K] AdeleRing (­ЮЊъ K) K)]

/-- The inclusion D╦Б Рєњ D_­ЮћИ╦Б as a group homomorphism. -/
noncomputable abbrev incl : D╦Б Рєњ* D_­ЮћИ╦Б :=
  Units.map Algebra.TensorProduct.includeLeftRingHom.toMonoidHom

namespace Aux

lemma existsE : РѕЃ E : Set (D_­ЮћИ), IsCompact E РѕД
    Рѕђ ¤є : D_­ЮћИ РЅЃРѓю+ D_­ЮћИ, addEquivAddHaarChar ¤є = 1 Рєњ РѕЃ eРѓЂ Рѕѕ E, РѕЃ eРѓѓ Рѕѕ E,
    eРѓЂ РЅа eРѓѓ РѕД ¤є eРѓЂ - ¤є eРѓѓ Рѕѕ Set.range (Algebra.TensorProduct.includeLeft : D РєњРѓљ[K] D_­ЮћИ) :=
  sorry

/-- An auxiliary set E used in the proof of Fukisaki's lemma. -/
def E : Set D_­ЮћИ := (existsE K D).choose

lemma E_compact : IsCompact (E K D) := (existsE K D).choose_spec.1

lemma E_noninjective_left {x : D_­ЮћИ╦Б} (h : x Рѕѕ ringHaarChar_ker D_­ЮћИ) :
    РѕЃ eРѓЂ Рѕѕ E K D, РѕЃ eРѓѓ Рѕѕ E K D, eРѓЂ РЅа eРѓѓ РѕД
    x * eРѓЂ - x * eРѓѓ Рѕѕ Set.range (Algebra.TensorProduct.includeLeft : D РєњРѓљ[K] D_­ЮћИ) :=
  (existsE K D).choose_spec.2 (ContinuousAddEquiv.mulLeft x) h

lemma E_noninjective_right {x : D_­ЮћИ╦Б} (h : x Рѕѕ ringHaarChar_ker D_­ЮћИ) :
    РѕЃ eРѓЂ Рѕѕ E K D, РѕЃ eРѓѓ Рѕѕ E K D, eРѓЂ РЅа eРѓѓ РѕД
    eРѓЂ * xРЂ╗┬╣ - eРѓѓ * xРЂ╗┬╣  Рѕѕ Set.range (Algebra.TensorProduct.includeLeft : D РєњРѓљ[K] D_­ЮћИ) := by
  let ¤є : D_­ЮћИ РЅЃРѓю+ D_­ЮћИ := ContinuousAddEquiv.mulRight xРЂ╗┬╣
  have h¤є : addEquivAddHaarChar ¤є = 1 := sorry
  exact (existsE K D).choose_spec.2 ¤є h¤є

open scoped Pointwise in
/-- An auxiliary set X used in the proof of Fukisaki's lemma. Defined as E - E. -/
def X : Set D_­ЮћИ := E K D - E K D

open scoped Pointwise in
/-- An auxiliary set Y used in the proof of Fukisaki's lemma. Defined as X * X. -/
def Y : Set D_­ЮћИ := X K D * X K D

lemma X_compact : IsCompact (X K D) := by
  simpa only [Set.image_prod, Set.image2_sub] using (IsCompact.image_of_continuousOn
    ((E_compact K D).prod (E_compact K D)) ((continuous_fst.sub continuous_snd).continuousOn))

lemma Y_compact : IsCompact (Y K D) := by
  simpa only [Set.image_prod, Set.image2_mul] using (IsCompact.image_of_continuousOn
    ((X_compact K D).prod (X_compact K D)) ((continuous_fst.mul continuous_snd).continuousOn))

lemma X_meets_kernel {╬▓ : D_­ЮћИ╦Б} (h╬▓ : ╬▓ Рѕѕ ringHaarChar_ker D_­ЮћИ) :
    РѕЃ x Рѕѕ X K D, РѕЃ d Рѕѕ Set.range (incl K D : D╦Б Рєњ D_­ЮћИ╦Б), ╬▓ * x = d := by
  obtain РЪеe1, he1, e2, he2, noteq, b, hbРЪЕ := E_noninjective_left K D h╬▓
  refine РЪеe1 - e2, by simpa only using (Set.sub_mem_sub he1 he2), ?_РЪЕ
  obtain РЪеb1, rflРЪЕ : IsUnit b := by
    simp_rw [Рєљ mul_sub_left_distrib, Algebra.TensorProduct.includeLeft_apply] at hb
    have h1 : РєЉ╬▓ * (e1 - e2) РЅа 0 := by
      simpa only [ne_eq, not_not, Units.mul_right_eq_zero] using (sub_ne_zero_of_ne noteq)
    simp only [isUnit_iff_ne_zero, ne_eq]
    rintro rfl
    simp only [Рєљ hb, TensorProduct.zero_tmul, ne_eq, not_true_eq_false] at h1
  exact РЪеincl K D b1, РЪеb1, rflРЪЕ, by simpa [mul_sub] using hb.symmРЪЕ

lemma X_meets_kernel' {╬▓ : D_­ЮћИ╦Б} (h╬▓ : ╬▓ Рѕѕ ringHaarChar_ker D_­ЮћИ) :
    РѕЃ x Рѕѕ X K D, РѕЃ d Рѕѕ Set.range (incl K D : D╦Б Рєњ D_­ЮћИ╦Б), x * ╬▓РЂ╗┬╣ = d := by
  obtain РЪеe1, he1, e2, he2, noteq, b, hbРЪЕ := E_noninjective_right K D h╬▓
  refine РЪеe1 - e2, by simpa only using (Set.sub_mem_sub he1 he2), ?_РЪЕ
  obtain РЪеb1, rflРЪЕ : IsUnit b := by
    simp_rw [Рєљ mul_sub_right_distrib, Algebra.TensorProduct.includeLeft_apply] at hb
    have h1 : (e1 - e2) * РєЉ╬▓РЂ╗┬╣ РЅа 0 := by
      simpa only [ne_eq, Units.mul_left_eq_zero] using (sub_ne_zero_of_ne noteq)
    simp only [isUnit_iff_ne_zero, ne_eq]
    rintro rfl
    simp only [Рєљ hb, TensorProduct.zero_tmul, ne_eq, not_true_eq_false] at h1
  exact РЪеincl K D b1, РЪеb1, rflРЪЕ, by simpa [sub_mul] using hb.symmРЪЕ

/-- An auxiliary set T used in the proof of Fukisaki's lemma. Defined as Y РѕЕ D╦Б. -/
def T : Set D_­ЮћИ╦Б := ((РєЉ) : D_­ЮћИ╦Б Рєњ D_­ЮћИ) РЂ╗┬╣' (Y K D) РѕЕ Set.range ((incl K D : D╦Б Рєњ D_­ЮћИ╦Б))

-- Need something saying D Ріє D_­ЮћИ is discrete

lemma T_finite : Set.Finite (T K D) := by
  have h : Set.Finite ((Y K D) РѕЕ (Set.range (Algebra.TensorProduct.includeLeft : D РєњРѓљ[K] D_­ЮћИ)))
      := by
    apply IsCompact.finite
    ┬и refine IsCompact.inter_right (Y_compact K D) ?_

      -- Subgroup.isClosed_of_discrete
      sorry
    ┬и -- follows form D being discrete

      sorry
  have h1 : Units.val '' T K D Ріє (Y K D) РѕЕ
      (Set.range (Algebra.TensorProduct.includeLeft : D РєњРѓљ[K] D_­ЮћИ)) := by
    rintro _ РЪеt, РЪеht1, d, rflРЪЕ, rflРЪЕ
    exact РЪеht1, d, rflРЪЕ
  exact Set.Finite.of_finite_image (Set.Finite.subset h h1) (Function.Injective.injOn Units.ext)

open scoped Pointwise in
/-- An auxiliary set C used in the proof of Fukisaki's lemma. Defined as TРЂ╗┬╣X ├Ќ X. -/
def C : Set (D_­ЮћИ ├Ќ D_­ЮћИ) := ((((РєЉ) : D_­ЮћИ╦Б Рєњ D_­ЮћИ) '' (T K D)РЂ╗┬╣) * X K D) ├Ќ╦б X K D

lemma C_compact : IsCompact (C K D) := by
  refine IsCompact.prod ?_ (X_compact K D)
  simpa only [Set.image_prod, Set.image2_mul] using
    (IsCompact.image_of_continuousOn (IsCompact.prod (IsCompact.image_of_continuousOn
    (IsCompact.inv (Set.Finite.isCompact (T_finite K D))) (Continuous.comp_continuousOn'
    (Units.continuous_val) (continuousOn_id' (T K D)РЂ╗┬╣)))
    (X_compact K D)) ((continuous_fst.mul continuous_snd).continuousOn))

lemma antidiag_mem_C {╬▓ : D_­ЮћИ╦Б} (h╬▓ : ╬▓ Рѕѕ ringHaarChar_ker D_­ЮћИ) :
    РѕЃ b Рѕѕ Set.range (incl K D : D╦Б Рєњ D_­ЮћИ╦Б),
    РѕЃ ╬й Рѕѕ ringHaarChar_ker D_­ЮћИ,
    ╬▓ = b * ╬й РѕД ((╬й : D_­ЮћИ), ((╬йРЂ╗┬╣ : D_­ЮћИ╦Б) : D_­ЮћИ)) Рѕѕ C K D := by
  obtain РЪеx1, hx1, b1, РЪеb1, rflРЪЕ, eq1РЪЕ := X_meets_kernel K D h╬▓
  obtain РЪеx2, hx2, b2, РЪеb2, rflРЪЕ, eq2РЪЕ := X_meets_kernel' K D h╬▓
  obtain РЪеx1, rflРЪЕ : IsUnit x1 := РЪеРєЉ╬▓РЂ╗┬╣ * incl K D b1,
    ((Units.eq_inv_mul_iff_mul_eq ╬▓).mpr eq1).symmРЪЕ
  obtain РЪеx2, rflРЪЕ : IsUnit x2 := РЪеincl K D b2 * ╬▓, ((Units.mul_inv_eq_iff_eq_mul ╬▓).mp eq2).symmРЪЕ
  have h : x2 * x1 Рѕѕ T K D := РЪеby simpa only [Y] using (Set.mul_mem_mul hx2 hx1), b2 * b1,
    by simpa using Units.eq_iff.mp (id (Eq.symm (by simpa [mul_assoc] using
    (Mathlib.Tactic.LinearCombination'.mul_pf eq2 eq1))))РЪЕ
  refine РЪеincl K D b1, by simp only [Set.mem_range, exists_apply_eq_apply],  x1РЂ╗┬╣, ?_,
    eq_mul_inv_of_mul_eq (Units.eq_iff.mp eq1), ?_, hx1РЪЕ
  ┬и rw [(Eq.symm (inv_mul_eq_of_eq_mul (eq_mul_inv_of_mul_eq (Units.eq_iff.mp eq1))))]
    exact (Subgroup.mul_mem_cancel_right (ringHaarChar_ker (D РіЌ[K] AdeleRing (­ЮЊъ K) K)) h╬▓).mpr
      ((Subgroup.inv_mem_iff (ringHaarChar_ker (D РіЌ[K] AdeleRing (­ЮЊъ K) K))).mpr
      (NumberField.AdeleRing.units_mem_ringHaarCharacter_ker K D b1))
  ┬и obtain РЪеt, ht, ht1РЪЕ := exists_eq_right'.mpr h
    simp_rw [(Eq.symm (inv_mul_eq_of_eq_mul (eq_mul_inv_of_mul_eq ht1)))]
    exact Set.mem_mul.mpr РЪеРєЉtРЂ╗┬╣, Set.mem_image_of_mem Units.val ht, x2, hx2, rflРЪЕ

end Aux

-- the рхљрхњрхќ is required to use Units.embedProduct
def inclРѓѓ : ringHaarChar_ker D_­ЮћИ Рєњ Prod D_­ЮћИ D_­ЮћИрхљрхњрхќ :=
  fun u => Units.embedProduct D_­ЮћИ (Subgroup.subtype (ringHaarChar_ker D_­ЮћИ) u)

/- incorporated into definition of M -- but left for clarity until merged
-- this is required to have M be the preimage of C under inclРѓѓ
def map1 : Prod D_­ЮћИ D_­ЮћИ Рєњ Prod D_­ЮћИ D_­ЮћИрхљрхњрхќ :=
  fun p => (p.1, MulOpposite.op p.2)
-/

def M : Set (ringHaarChar_ker D_­ЮћИ) := Set.preimage (inclРѓѓ K D)
  (Set.image (fun p => (p.1, MulOpposite.op p.2)) (Aux.C K D))

abbrev MtoQuot (a : ringHaarChar_ker D_­ЮћИ) : (ringHaarChar_ker D_­ЮћИ РДИ
    (MonoidHom.range (incl K D)).comap (ringHaarChar_ker D_­ЮћИ).subtype) := a

lemma MtoQuot_cont : Continuous (MtoQuot K D) := QuotientGroup.continuous_mk

/- The following is part of the proof of 12.11 on the blueprint - perhaps this can be moved there
  in more generality later
-/

def p : Prod D_­ЮћИ D_­ЮћИрхљрхњрхќ Рєњ D_­ЮћИ :=
  fun p => p.1 * MulOpposite.unop p.2

def q : Prod D_­ЮћИ D_­ЮћИрхљрхњрхќ Рєњ D_­ЮћИ :=
  fun p => MulOpposite.unop p.2 * p.1

lemma p_cont : Continuous (p K D) := Continuous.mul (continuous_fst)
  (Continuous.comp (MulOpposite.continuous_unop) continuous_snd)

lemma q_cont : Continuous (q K D) := Continuous.mul (Continuous.comp (MulOpposite.continuous_unop)
  continuous_snd) (continuous_fst)

lemma renameME : (Set.range РЄЉ(Units.embedProduct (D РіЌ[K] AdeleRing (­ЮЊъ K) K))) =
    Set.preimage (p K D) {1} РѕЕ Set.preimage (q K D) {1} := by
  ext x
  simp only [Set.mem_range, Units.embedProduct_apply, Set.mem_inter_iff, Set.mem_preimage,
    Set.mem_singleton_iff]
  constructor
  ┬и rintro РЪеy, РЪеx1, x2РЪЕРЪЕ
    exact РЪеby simp only [p,MulOpposite.unop_op, Units.mul_inv],
      by simp only [q, MulOpposite.unop_op, Units.inv_mul]РЪЕ
  ┬и rw [p,q]
    rintro РЪеhp, hqРЪЕ
    obtain РЪеx1, hx1РЪЕ : IsUnit x.1 := isUnit_iff_exists_and_exists.mpr
      РЪеРЪеMulOpposite.unop x.2, hpРЪЕ, РЪеMulOpposite.unop x.2, hqРЪЕРЪЕ
    use x1
    rw [hx1]
    have : MulOpposite.op РєЉx1РЂ╗┬╣ = x.2 := by
      refine MulOpposite.unop_inj.mp ?_
      rw [Рєљ hx1] at hp
      exact Units.inv_eq_of_mul_eq_one_right hp
    simp only [this]

local instance : T1Space (D РіЌ[K] AdeleRing (­ЮЊъ K) K) := by
  -- is this true? Does this mean Hausdorff - Frechet space is different no??
  sorry

lemma embedProduct_closed : IsClosed (Set.range РЄЉ(Units.embedProduct (D РіЌ[K] AdeleRing (­ЮЊъ K) K)))
    := by
  rw [renameME]
  exact IsClosed.inter (IsClosed.preimage (p_cont K D) (isClosed_singleton))
    (IsClosed.preimage (q_cont K D) (isClosed_singleton))

lemma M_compact : IsCompact (M K D) := by
  apply Topology.IsClosedEmbedding.isCompact_preimage
  ┬и unfold inclРѓѓ
    apply Topology.IsClosedEmbedding.comp
    ┬и exact { toIsEmbedding := Units.isEmbedding_embedProduct, isClosed_range :=
        embedProduct_closed K D }
    ┬и

      /-
      refine Topology.IsClosedEmbedding.of_continuous_injective_isClosedMap ?_ ?_ ?_
      ┬и exact continuous_iff_le_induced.mpr fun U a Рєд a
      ┬и exact Subgroup.subtype_injective (ringHaarChar_ker (D РіЌ[K] AdeleRing (­ЮЊъ K) K))
      ┬и simp only [Subgroup.coe_subtype]
        refine Topology.IsInducing.isClosedMap ?_ ?_
        ┬и exact { eq_induced := rfl }
        ┬и simp only [Subtype.range_coe_subtype, SetLike.setOf_mem_eq]
          -- ringHaarChar is closed since it is the primage of a closed set under a continuous map
          -- {1} is closed since it is a singleton in a Hausdorff (T1?) space
          -- problem is we want to show the image of this is closed... so maybe I need to rework
          -- this section of the proof
      -/
          sorry
  ┬и refine IsCompact.image (Aux.C_compact K D) (Continuous.prodMk (continuous_fst) ?_)
    refine Continuous.comp ?_ (continuous_snd)
    ┬и rw [@continuous_induced_rng]
      exact { isOpen_preimage := fun s a Рєд a }

lemma MtoQuot_surjective :
    (MtoQuot K D) '' (M K D) = Set.univ := by
  rw [Set.eq_univ_iff_forall]
  rintro РЪеa, haРЪЕ
  obtain РЪеc, hc, ╬й, h╬й, rfl, h31РЪЕ := Aux.antidiag_mem_C K D ha
  simp only [MtoQuot, Subgroup.comap_subtype, Set.mem_image, Subtype.exists]
  refine РЪе╬й, h╬й, ?_, ?_ РЪЕ
  ┬и simp only [M, Set.mem_preimage, Set.mem_image, Prod.exists]
    refine РЪе╬й, Units.val (╬йРЂ╗┬╣), h31, rflРЪЕ
  ┬и apply QuotientGroup.eq

    -- should be wanting the right relation!
    sorry

lemma compact_quotient : CompactSpace (ringHaarChar_ker D_­ЮћИ РДИ
    (MonoidHom.range (incl K D)).comap (ringHaarChar_ker D_­ЮћИ).subtype) :=
  isCompact_univ_iff.mp (by simpa only [MtoQuot_surjective] using
    (IsCompact.image (M_compact K D) (MtoQuot_cont K D)))

end NumberField.AdeleRing.DivisionAlgebra

section FiniteAdeleRing

instance : Algebra (FiniteAdeleRing (­ЮЊъ K) K) (D РіЌ[K] FiniteAdeleRing (­ЮЊъ K) K) :=
  Algebra.TensorProduct.rightAlgebra

-- this is in FLT somewhere
instance : Module.Finite (FiniteAdeleRing (­ЮЊъ K) K) (D РіЌ[K] FiniteAdeleRing (­ЮЊъ K) K) := sorry

/-- The ­ЮћИ_K^Рѕъ-module topology on D РіЌ ­ЮћИ_K^Рѕъ-/
local instance : TopologicalSpace (D РіЌ[K] FiniteAdeleRing (­ЮЊъ K) K) :=
  moduleTopology (FiniteAdeleRing (­ЮЊъ K) K) _

local instance : IsModuleTopology (FiniteAdeleRing (­ЮЊъ K) K) (D РіЌ[K] (FiniteAdeleRing (­ЮЊъ K) K)) :=
  РЪеrflРЪЕ

variable [FiniteDimensional K D]

-- Instance to help speed up instance synthesis
instance : NonUnitalNonAssocRing (D РіЌ[K] (FiniteAdeleRing (­ЮЊъ K) K)) :=
  let r := Algebra.TensorProduct.instRing.toNonUnitalRing
  r.toNonUnitalNonAssocRing

-- Instance to help speed up instance synthesis
instance : NonAssocSemiring (D РіЌ[K] (FiniteAdeleRing (­ЮЊъ K) K)) :=
  Algebra.TensorProduct.instRing.toNonAssocSemiring

instance : IsTopologicalRing (D РіЌ[K] (FiniteAdeleRing (­ЮЊъ K) K)) :=
  IsModuleTopology.Module.topologicalRing (FiniteAdeleRing (­ЮЊъ K) K) _

variable [Algebra.IsCentral K D]

/-- Dfx is notation for (D РіЌ ­ЮћИ_K^Рѕъ)╦Б. -/
abbrev Dfx := (D РіЌ[K] (FiniteAdeleRing (­ЮЊъ K) K))╦Б

/-- The inclusion D╦Б Рєњ (D РіЌ ­ЮћИ_K^Рѕъ)╦Б as a group homomorphism. -/
noncomputable abbrev inclРѓЂ : D╦Б Рєњ* Dfx K D :=
  Units.map Algebra.TensorProduct.includeLeftRingHom.toMonoidHom

theorem NumberField.FiniteAdeleRing.DivisionAlgebra.units_cocompact :
    CompactSpace (Dfx K D РДИ (inclРѓЂ K D).range) := by
  sorry

-- Voight "Main theorem 27.6.14(b) (Fujisaki's lemma)"
/-!
If `D` is a finite-dimensional division algebra over a number field `K`
then the double coset space `D╦Б \ (D РіЌ ­ЮћИ_K^infty)╦Б / U` is finite for any compact open subgroup `U`
of `(D РіЌ ­ЮћИ_F^infty)╦Б`.
-/
theorem NumberField.FiniteAdeleRing.DivisionAlgebra.finiteDoubleCoset
    {U : Subgroup (Dfx K D)} (hU : IsOpen (U : Set (Dfx K D))) :
    Finite (Doset.Quotient (Set.range (inclРѓЂ K D)) U) := by
  sorry

end FiniteAdeleRing
