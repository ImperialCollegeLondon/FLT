import FLT.Mathlib.Algebra.Algebra.Bilinear
import FLT.Mathlib.Algebra.Algebra.Pi
import FLT.Mathlib.Algebra.Module.Submodule.Basic
import FLT.Mathlib.NumberTheory.RamificationInertia.Basic
import FLT.Mathlib.Topology.Algebra.Module.Equiv
import FLT.Mathlib.Topology.Algebra.Module.ModuleTopology
import FLT.Mathlib.Topology.Algebra.UniformRing
import FLT.Mathlib.Topology.Algebra.Valued.ValuationTopology
import FLT.Mathlib.Topology.Algebra.Valued.WithVal
import FLT.Mathlib.RingTheory.TensorProduct.Basis
import FLT.Mathlib.RingTheory.Finiteness.Pi
import Mathlib.Algebra.Algebra.Subalgebra.Pi
import Mathlib.Algebra.BigOperators.Group.Finset.Basic
import Mathlib.Algebra.Group.Int.TypeTags
import Mathlib.Data.Int.WithZero
import Mathlib.RingTheory.DedekindDomain.FiniteAdeleRing
import Mathlib.Topology.Algebra.Algebra.Equiv
import Mathlib.Topology.Algebra.Module.ModuleTopology
import Mathlib.Topology.Algebra.Valued.NormedValued
import Mathlib.RingTheory.Valuation.RankOne
import Mathlib.Topology.Algebra.Module.FiniteDimension
import FLT.DedekindDomain.AdicValuation
import FLT.DedekindDomain.Completion.BaseChange
import FLT.DedekindDomain.FiniteAdeleRing.TensorPi
import FLT.Mathlib.Topology.Algebra.RestrictedProduct
import Mathlib.LinearAlgebra.TensorProduct.Prod
import Mathlib.Algebra.Colimit.Module
import Mathlib.RingTheory.Flat.Basic

variable {Œπ : Type*}
variable {R : Œπ ‚Üí Type*}
variable {‚Ñ± : Filter Œπ}

variable {S : Œπ ‚Üí Type*} -- subobject type
variable [Œ† i, SetLike (S i) (R i)]
variable {B : Œ† i, S i}

open scoped RestrictedProduct TensorProduct

variable {A : Type*} [CommRing A]


-- In open PR #25715
-- restricted product of addcommgroups is an addcommgroup
instance [Œ† i, AddCommGroup (R i)] [‚àÄ i, AddSubgroupClass (S i) (R i)]:
    AddCommGroup (Œ† ≥ i, [R i, B i]_[‚Ñ±]) where
  __ := inferInstanceAs (AddGroup (Œ† ≥ i, [R i, B i]_[‚Ñ±]))
  add_comm a b := by ext i; simp [add_comm]

-- when #25715 lands we'll be able to change these to AddCommMonoid
-- restricted product of A-modules is an A-module
instance [Œ† i, AddCommGroup (R i)] [‚àÄ i, Module A (R i)]
    -- next line is how we do "SubmoduleClass"
    [‚àÄ i, AddSubgroupClass (S i) (R i)] [‚àÄ i, SMulMemClass (S i) A (R i)] :
    Module A (Œ† ≥ i, [R i, B i]_[‚Ñ±]) where
      smul a x := ‚ü®fun i ‚Ü¶ a ‚Ä¢ x i, Filter.Eventually.mono x.property (fun _ hi ‚Ü¶
     SMulMemClass.smul_mem a hi)‚ü©
      one_smul := one_smul _
      mul_smul := mul_smul
      smul_zero := smul_zero
      smul_add := smul_add
      add_smul := add_smul
      zero_smul := zero_smul _

noncomputable def Submodule.lTensor (M : Type*) {N : Type*} [AddCommGroup M] [Module A M]
    [AddCommGroup N] [Module A N] (P : Submodule A N) : Submodule A (M ‚äó[A] N) :=
  LinearMap.range (P.subtype.lTensor M)

open Filter

noncomputable def RestrictedProduct.principal [Œ† i, AddCommGroup (R i)]
    [‚àÄ i, Module A (R i)] {C : Œ† i, Submodule A (R i)} {S: Set Œπ}:
   (Œ† ≥ i, [R i, C i]_[ùìü S]) ‚âÉ‚Çó[A] ((Œ† v : S, R v) √ó
  (Œ† v : {v // v ‚àâ S}, R v)) := sorry

noncomputable def RestrictedProduct.principal_tensor_comm' [Œ† i, AddCommGroup (R i)]
    [‚àÄ i, Module A (R i)] {C : Œ† i, Submodule A (R i)} {M : Type*} [AddCommGroup M] [Module A M]
    [Module.FinitePresentation A M]{S: Set Œπ}:
   M ‚äó[A] (Œ† ≥ i, [R i, C i]_[ùìü S]) ‚âÉ‚Çó[A] (Œ† ≥ i, [M ‚äó[A] R i, (C i).lTensor M]_[ùìü S]) := sorry


-- this now compiles
noncomputable def RestrictedProduct.tensor_comm' [Œ† i, AddCommGroup (R i)]
    [‚àÄ i, Module A (R i)] {C : Œ† i, Submodule A (R i)}
    {M : Type*} [AddCommGroup M] [Module A M] [Module.FinitePresentation A M] [Module.Flat A M] :
    M ‚äó[A] (Œ† ≥ i, [R i, C i]_[‚Ñ±]) ‚âÉ‚Çó[A] Œ† ≥ i, [M ‚äó[A] R i, (C i).lTensor M]_[‚Ñ±] :=
  LinearEquiv.ofBijective (TensorProduct.lift {
    toFun m := {
      toFun x := ‚ü®fun i ‚Ü¶ m ‚äó‚Çú (x i), Filter.Eventually.mono x.property (fun i hi ‚Ü¶
     LinearMap.mem_range.mpr ‚ü®m ‚äó‚Çú[A] ‚ü®x i, hi‚ü©, rfl‚ü©)‚ü©
      map_add' x y := by
        ext i
        simp only [add_apply, mk_apply, TensorProduct.tmul_add]
      map_smul' a x := by
        ext i
        simp only [smul_apply, TensorProduct.tmul_smul, mk_apply, RingHom.id_apply]
    }
    map_add' x y := by
      refine LinearMap.ext (fun x‚ÇÅ ‚Ü¶ ?_)
      ext i
      simp only [LinearMap.coe_mk, AddHom.coe_mk, mk_apply, LinearMap.add_apply, add_apply,
        TensorProduct.add_tmul]
    map_smul' a x := by
      refine LinearMap.ext (fun x‚ÇÅ ‚Ü¶ ?_)
      ext i
      simp only [LinearMap.coe_mk, AddHom.coe_mk, mk_apply, RingHom.id_apply, LinearMap.smul_apply,
        smul_apply, TensorProduct.smul_tmul']
  }) ‚ü®
  fun a b h ‚Ü¶ by
    -- injectivity proof: if `a`, `b` in `M ‚äó[A] Œ† ≥ (i : Œπ), [R i, ‚Üë(C i)]_[‚Ñ±]`
    -- and their images in `Œ† ≥ (i : Œπ), [M ‚äó[A] R i, ‚Üë(Submodule.lTensor M (C i))]_[‚Ñ±]`
    -- are the same, then choose some `S ‚àà ‚Ñ±` such that `a`, `b` are both in
    -- `M ‚äó ((‚àè i ‚àà S, C i) √ó (‚àè i ‚àâ S, R i))`, and then by your earlier work we know
    -- that the map from this to `(‚àè i ‚àà S, M ‚äó C i) √ó (‚àè i ‚àâ S, M ‚äó R i)` is injective,
    -- and then by flatness the map from that to
    -- `Œ† ≥ (i : Œπ), [M ‚äó[A] R i, ‚Üë(Submodule.lTensor M (C i))]_[‚Ñ±]` is injective,
    -- and `a` and `b` have become equal after the composite of those two injections,
    -- so they are equal.
    have h_finite : ‚àÉ (S : Finset Œπ), S.toSet ‚àà ‚Ñ± ‚àß
    (‚àÄ x ‚àà {a, b}, ‚àÉ (f : Œπ ‚Üí A), Set.finite {i | f i ‚â† 0} ‚àß
     ‚àÄ i ‚àâ S, (TensorProduct.lift _ x : _) i ‚àà Submodule.lTensor M (C i)) := by
      sorry


    -- haveI {S: Set Œπ} {h: S ‚àà ‚Ñ±} : AddCommMonoid ((Œ† i ‚àà S, C i) √ó (Œ† i ‚àâ S, R i)) := sorry
    -- have : ‚àÉS ‚àà ‚Ñ±, a.val ‚àà (M ‚äó[A] ((Œ† i ‚àà S, C i) √ó (Œ† i ‚àâ S, R i))) ‚àß
    --   b.val ‚àà (M ‚äó[A] ((Œ† i ‚àà S, C i) √ó (Œ† i ‚àâ S, R i))) := sorry
    sorry,
  by
    intro y
    -- by definition `y ‚àà (‚àè i ‚àà S, ‚Üë(Submodule.lTensor M (C i))) √ó (‚àè i ‚àâ S, M ‚äó R i)`
    -- for some `S ‚àà ‚Ñ±`, and there's a surjection (in fact a bijection) from
    -- `(‚àè i ‚àà S, M ‚äó (C i)) √ó (‚àè i ‚àâ S, M ‚äó R i)` onto this, and then by your earlier
    -- work there's something in `M ‚äó ((‚àè i ‚àà S, C i) √ó (‚àè i ‚àâ S, R i))` which hits
    -- this, and the image of that thing in `M ‚äó[A] Œ† ≥ (i : Œπ), [R i, ‚Üë(C i)]_[‚Ñ±]`
    -- will do
    sorry‚ü©























#exit

variable (A K L B : Type*) [CommRing A] [CommRing B] [Algebra A B] [Field K] [Field L]
    [Algebra A K] [IsFractionRing A K] [Algebra B L] [IsDedekindDomain A]
    [Algebra K L] [Algebra A L] [IsScalarTower A B L] [IsScalarTower A K L]
    [IsIntegralClosure B A L] [FiniteDimensional K L] [Module.Finite A B]
    [IsDedekindDomain B] [IsFractionRing B L]

variable (M : Type*) [AddCommGroup M] [Module A M] [Module.FinitePresentation A M]
namespace IsDedekindDomain

open IsDedekindDomain HeightOneSpectrum

#check Module.DirectLimit


noncomputable instance : DecidableEq (HeightOneSpectrum A) :=
  Classical.typeDecidableEq (HeightOneSpectrum A)



noncomputable def f (S T: Finset (HeightOneSpectrum A)) (h : S ‚â§ T) :
  ((Œ† v : S, v.1.adicCompletion K) √ó
  (Œ† v : {v // v ‚àâ S}, (adicCompletionIntegers K v.1))) ‚Üí‚Çó[A]
  ((Œ† v : T, v.1.adicCompletion K) √ó
  (Œ† v : {v // v ‚àâ T}, (adicCompletionIntegers K v.1))) where
    toFun x := (fun v ‚Ü¶
      if h' : (v : HeightOneSpectrum A) ‚àà S then
        x.1 ‚ü®v, h'‚ü©
      else
        algebraMap _ _ (x.2 ‚ü®v, h'‚ü©),
     fun v ‚Ü¶ x.2 ‚ü®v, Set.notMem_subset h v.2‚ü©)
    map_add' x y := by
      simp only [Prod.fst_add, Pi.add_apply, Prod.snd_add, ValuationSubring.algebraMap_apply,
        AddMemClass.coe_add, Prod.mk_add_mk, Prod.mk.injEq]
      constructor
      ¬∑ ext v
        by_cases hv : (v : HeightOneSpectrum A) ‚àà S
        ¬∑ simp [hv]
        ¬∑ simp [hv]
      ¬∑ ext v
        simp only [AddMemClass.coe_add, Pi.add_apply]
    map_smul' r x := by
      simp only [Prod.smul_fst, Pi.smul_apply, Prod.smul_snd, ValuationSubring.algebraMap_apply,
        coe_smul_adicCompletionIntegers, RingHom.id_apply, Prod.smul_mk, Prod.mk.injEq]
      constructor
      ¬∑ ext v
        by_cases hv : (v : HeightOneSpectrum A) ‚àà S
        ¬∑ simp [hv]
        ¬∑ simp [hv]
      ¬∑ ext v
        simp only [coe_smul_adicCompletionIntegers, Pi.smul_apply]


noncomputable def direct_limit : (@Module.DirectLimit A _ (Finset (HeightOneSpectrum A)) _
  (fun S ‚Ü¶ ((Œ† v : S, v.1.adicCompletion K) √ó (Œ† v : (Set.compl (Finset.toSet S)),
  (adicCompletionIntegers K v.1)))) _ _ (f A K) _) ‚âÉ‚Çó[A] FiniteAdeleRing A K := by
  refine LinearEquiv.ofBijective (Module.DirectLimit.lift A (Finset (HeightOneSpectrum A))
    (fun S ‚Ü¶ ((Œ† v : S, v.1.adicCompletion K) √ó (Œ† v : (Set.compl (Finset.toSet S)),
   (adicCompletionIntegers K v.1)))) (f A K) ?_ ?_) ‚ü®?_, ?_‚ü©
  ¬∑ intro v
    simp only
    -- can rw as restricted product on princpal filter and go from there?
    sorry
  ¬∑ intro v w
    sorry
  ¬∑ apply Module.DirectLimit.lift_injective
    intro v

    sorry
  ¬∑
    sorry




#exit



-- def G (S : Finset (HeightOneSpectrum A)):=
-- ((Œ† v : S, v.1.adicCompletion K) √ó (Œ† v : (Set.compl (Finset.toSet S)), (adicCompletionIntegers K v.1)))

-- #check G A K

-- noncomputable instance (S : Finset (HeightOneSpectrum A)) : AddCommGroup (G A K S) :=
--   Prod.instAddCommGroup

-- instance (S : Finset (HeightOneSpectrum A)) : Module A (G A K S) := by
--   sorry

def DirectLimit' :=
  @Module.DirectLimit A _ (Finset (HeightOneSpectrum A)) _
  (fun S ‚Ü¶ ((Œ† v : S, v.1.adicCompletion K) √ó (Œ† v : (Set.compl (Finset.toSet S)),
  (adicCompletionIntegers K v.1)))) _ _ (f A K) _

-- noncomputable def LHS (S : FiniteSubsets A) :=
--   M ‚äó[A] ((Œ† v : S.val, adicCompletion K v.1) √ó
--           (Œ† v : (Set.compl S.val), adicCompletionIntegers K v.1))

-- noncomputable def RHS (S : FiniteSubsets A) :=
--   (Œ† v : S.val, M ‚äó[A] adicCompletion K v.1) √ó
--   (Œ† v : (Set.compl S.val), M ‚äó[A] adicCompletionIntegers K v.1)

-- instance (S: FiniteSubsets A): AddCommMonoid (LHS A K M S) := by
--   dsimp [LHS]
--   exact TensorProduct.addCommMonoid

variable (iso : ‚àÄ S : FiniteSubsets A, (M ‚äó[A] ((Œ† v : S.val, adicCompletion K v.1) √ó
          (Œ† v : (Set.compl S.val), adicCompletionIntegers K v.1))) ‚âÉ‚Çó[A]
          ((Œ† v : S.val, M ‚äó[A] adicCompletion K v.1) √ó
  (Œ† v : (Set.compl S.val), M ‚äó[A] adicCompletionIntegers K v.1)))

let q : ‚Ñ§ := 1
def LHS_limit : Type* :=
  lim (fun S : FiniteSubsets => (M ‚äó[A] ((Œ† v : S.val, adicCompletion K v.1) √ó
          (Œ† v : (Set.compl S.val), adicCompletionIntegers K v.1))))



end IsDedekindDomain
