import FLT.Mathlib.Algebra.Algebra.Bilinear
import FLT.Mathlib.Algebra.Algebra.Pi
import FLT.Mathlib.Algebra.Module.Submodule.Basic
import FLT.Mathlib.NumberTheory.RamificationInertia.Basic
import FLT.Mathlib.Topology.Algebra.Module.Equiv
import FLT.Mathlib.Topology.Algebra.Module.ModuleTopology
import FLT.Mathlib.Topology.Algebra.UniformRing
import FLT.Mathlib.Topology.Algebra.Valued.ValuationTopology
import FLT.Mathlib.Topology.Algebra.Valued.WithVal
import FLT.Mathlib.RingTheory.TensorProduct.Basis
import FLT.Mathlib.RingTheory.Finiteness.Pi
import Mathlib.Algebra.Algebra.Subalgebra.Pi
import Mathlib.Algebra.BigOperators.Group.Finset.Basic
import Mathlib.Algebra.Group.Int.TypeTags
import Mathlib.Data.Int.WithZero
import Mathlib.RingTheory.DedekindDomain.FiniteAdeleRing
import Mathlib.Topology.Algebra.Algebra.Equiv
import Mathlib.Topology.Algebra.Module.ModuleTopology
import Mathlib.Topology.Algebra.Valued.NormedValued
import Mathlib.RingTheory.Valuation.RankOne
import Mathlib.Topology.Algebra.Module.FiniteDimension
import FLT.DedekindDomain.AdicValuation
import FLT.DedekindDomain.Completion.BaseChange
import FLT.Mathlib.Topology.Algebra.RestrictedProduct.Basic
import Mathlib.LinearAlgebra.TensorProduct.Prod
import Mathlib.Algebra.Colimit.Module
import Mathlib.RingTheory.Flat.Basic
import FLT.DedekindDomain.FiniteAdeleRing.TensorPi
import Mathlib.Order.DirectedInverseSystem




section IsDirectLimit

namespace Module

variable {R : Type*} [Semiring R] {Î¹ : Type*} [Preorder Î¹] (M : Î¹ â†’ Type*) (P : Type*)
variable [AddCommMonoid P] [Module R P]
variable [âˆ€ i, AddCommMonoid (M i)] [âˆ€ i, Module R (M i)] (f : âˆ€ i j, i â‰¤ j â†’ M i â†’â‚—[R] M j)
variable (g : âˆ€ i, M i â†’â‚—[R] P) (Hg : âˆ€ i j hij x, g j (f i j hij x) = g i x)
variable [DecidableEq Î¹] [IsDirected Î¹ (Â· â‰¤ Â·)] [Nonempty Î¹] [DirectedSystem M (f Â· Â· Â·)]

@[mk_iff] class IsDirectLimit : Prop where
  surj : âˆ€ m : P, âˆƒ i, âˆƒ mi : M i, g i mi = m
  inj :  âˆ€ i j, âˆ€ mi : M i, âˆ€ mj : M j, g i mi = g j mj â†’ âˆƒ (k : Î¹) (hik : i â‰¤ k) (hjk : j â‰¤ k),
      f i k hik mi = f j k hjk mj

instance isDirectLimit : IsDirectLimit M (Module.DirectLimit M f) f
  (Module.DirectLimit.of R Î¹ M f) where
  surj := Module.DirectLimit.exists_of
  inj i j mi mj h := by
    apply_fun Module.DirectLimit.linearEquiv _ _ at h
    simp_rw [Module.DirectLimit.linearEquiv_of] at h
    have âŸ¨k, hi, hj, hijâŸ© := Quotient.exact h
    exact âŸ¨k, hi, hj, hijâŸ©

end Module

end IsDirectLimit


section RestrictedProduct



open Set Filter

variable {Î¹ : Type*} {ð“• : Filter Î¹}

variable (ð“•) in
/-- The complements of sets in a `Filter`.
E.g. for the cofinite filter, these are just the finite subsets. -/
def Filter.complement : Set (Set Î¹) := (fun S => Sá¶œ) '' ð“•.sets

theorem principal_filter_order {Sâ‚ Sâ‚‚ : ð“•.complement} (h : Sâ‚ â‰¤ Sâ‚‚) :
    (ð“Ÿ Sâ‚‚á¶œ : Filter Î¹) â‰¤ ð“Ÿ Sâ‚á¶œ := by
  simp only [le_principal_iff, mem_principal, compl_subset_compl]; exact h

theorem filter_bot :
    âˆ€ S : ð“•.complement, ð“• â‰¤ (ð“Ÿ Sá¶œ : Filter Î¹) := by
  intro S
  simp only [le_principal_iff]
  refine Filter.mem_sets.mp ?_
  have h : ð“•.sets = (fun S => Sá¶œ) '' (ð“•.complement) := by
    rw[complement]
    exact Eq.symm (compl_compl_image ð“•.sets)
  rw[h]
  simp

open scoped RestrictedProduct

variable {R : Î¹ â†’ Type*} {A : (i : Î¹) â†’ Set (R i)}

variable (A) in
/-- This is (isomorphic to) `(Î  i âˆˆ S, R i) Ã— (Î  i âˆ‰ S, A i)` -/
def mem_A_away_from_S (S : ð“•.complement) : Type _ :=
  Î Ê³ i, [R i, A i]_[ð“Ÿ Sá¶œ]

/-- The inclusions between `mem_A_away_from_S` which will form the directed system. -/
def inclusion (Sâ‚ Sâ‚‚ : ð“•.complement) (h : Sâ‚ â‰¤ Sâ‚‚) :
    mem_A_away_from_S A Sâ‚ â†’ mem_A_away_from_S A Sâ‚‚ :=
  RestrictedProduct.inclusion _ _ (principal_filter_order h)

instance directed_system :
    @DirectedSystem (ð“•.complement) _ (mem_A_away_from_S A) (inclusion) where
  map_self _ _ := rfl
  map_map _ _ _ _ _ _ := rfl

/-- The maps from the directed system to the actual restricted product. -/
def inclusion_to_restrictedProduct (S : ð“•.complement) :
    mem_A_away_from_S A S â†’ Î Ê³ i, [R i, A i]_[ð“•] :=
  RestrictedProduct.inclusion _ _ (filter_bot S)

-- ....


end RestrictedProduct



variable {Î¹ : Type*} {R : Î¹ â†’ Type*} {â„± : Filter Î¹}

variable {T : Î¹ â†’ Type*} -- subobject type
variable [Î  i, SetLike (T i) (R i)]
variable {B : Î  i, T i}

open scoped RestrictedProduct TensorProduct Module.IsDirectLimit

variable {A : Type*} [CommRing A]

-- In open PR #25715
-- restricted product of addcommgroups is an addcommgroup
instance [Î  i, AddCommGroup (R i)] [âˆ€ i, AddSubgroupClass (T i) (R i)] :
    AddCommGroup (Î Ê³ i, [R i, B i]_[â„±]) where
  __ := inferInstanceAs (AddGroup (Î Ê³ i, [R i, B i]_[â„±]))
  add_comm a b := by ext i; simp [add_comm]

-- when #25715 lands we'll be able to change these to AddCommMonoid
-- restricted product of A-modules is an A-module
instance [Î  i, AddCommGroup (R i)] [âˆ€ i, Module A (R i)]
    -- next line is how we do "SubmoduleClass"
    [âˆ€ i, AddSubgroupClass (T i) (R i)] [âˆ€ i, SMulMemClass (T i) A (R i)] :
    Module A (Î Ê³ i, [R i, B i]_[â„±]) where
      smul a x := âŸ¨fun i â†¦ a â€¢ x i, Filter.Eventually.mono x.property (fun _ hi â†¦
     SMulMemClass.smul_mem a hi)âŸ©
      one_smul b := by ext; simp
      mul_smul x y b := by ext; simp [mul_smul]
      smul_zero b := by ext; simp
      smul_add x a b := by ext; simp
      add_smul a b x := by
        ext
        simp only [RestrictedProduct.smul_apply, RestrictedProduct.add_apply, add_smul]
      zero_smul b := by ext; simp

noncomputable def Submodule.lTensor (M : Type*) {N : Type*} [AddCommGroup M] [Module A M]
    [AddCommGroup N] [Module A N] (P : Submodule A N) : Submodule A (M âŠ—[A] N) :=
  LinearMap.range (P.subtype.lTensor M)


variable {Î¹ : Type*} {R : Î¹ â†’ Type*} {â„± : Filter Î¹} [Preorder Î¹]

variable {T : Î¹ â†’ Type*} -- subobject type
variable [Î  i, SetLike (T i) (R i)]
variable {B : Î  i, T i}
variable {A : Type*} [CommRing A]

variable [Î  i, AddCommGroup (R i)] [âˆ€ i, Module A (R i)] {C : âˆ€ i, Submodule A (R i)}
{M : Type*} [AddCommGroup M] [Module A M] [Module.FinitePresentation A M] (S : Filter.complement â„±)

open Set Filter RestrictedProduct

instance add (S : â„±.complement) :
  AddCommMonoid (mem_A_away_from_S (R:=R) (fun i â†¦ (C i : Set (R i))) S) := by
  dsimp [mem_A_away_from_S]
  exact AddCommGroup.toDivisionAddCommMonoid.toAddCommMonoid

instance module (S : â„±.complement) :
  Module A (mem_A_away_from_S (R:=R) (fun i â†¦ (C i : Set (R i))) S) := by
  dsimp [mem_A_away_from_S]
  exact
    Â«instModuleRestrictedProductCoeOfSMulMemClass_external:file:///c%3A/Users/Maddy/Documents/Github/FLT/FLT/DedekindDomain/FiniteAdeleRing/Test.LeanÂ»



def inclusion_module (Sâ‚ Sâ‚‚ : â„±.complement) (h : Sâ‚ â‰¤ Sâ‚‚) :
    mem_A_away_from_S (fun i â†¦ (C i : Set (R i))) Sâ‚ â†’â‚—[A]
      mem_A_away_from_S ((fun i â†¦ (C i : Set (R i)))) Sâ‚‚ where
  __ := RestrictedProduct.inclusion R _ (principal_filter_order h)
  map_mul' _ _ := rfl





#check _root_.inclusion (ð“• := â„±) (A:= (fun i â†¦ (C i : Set (R i))))

#check Module.IsDirectLimit (mem_A_away_from_S (ð“• := â„±) (fun i â†¦ (C i : Set (R i))))
  Î Ê³ i, [R i, C i]_[â„±] --(_root_.inclusion (ð“• := â„±) (A:= (fun i â†¦ (C i : Set (R i)))))

instance RestrictedProductIsDirectLimit :
  Module.IsDirectLimit R Î Ê³ i, [R i, C i]_[â„±] (inclusion_to_restrictedProduct C S) := sorry





variable {Î¹ : Type*} (R : Î¹ â†’ Type*) (S : Set Î¹) [âˆ€ i, Decidable (i âˆˆ S)]

open scoped Filter

namespace RestrictedProduct

section type

variable (A : (i : Î¹) â†’ Set (R i))

def principalEquivProd : Î Ê³ i, [R i, A i]_[ð“Ÿ S] â‰ƒ
    (Î  i : {i // i âˆˆ S}, A i) Ã— (Î  i : {i // i âˆ‰ S}, R i) where
  toFun x := (fun i â†¦ âŸ¨x i, x.property i.propertyâŸ©, fun i â†¦ x i)
  invFun y := âŸ¨fun i â†¦ if hi : i âˆˆ S then y.1 âŸ¨i, hiâŸ© else y.2 âŸ¨i, hiâŸ©,
  Filter.eventually_principal.mpr (fun i hi â†¦ by simp only [hi]; exact (y.1 âŸ¨i, hiâŸ©).2)âŸ©
  left_inv x := by
    simp only [dite_eq_ite, ite_self]
    rfl
  right_inv x := by
    simp only [mk_apply, Subtype.coe_prop, â†“reduceDIte, Subtype.coe_eta]
    ext i
    Â· rfl
    Â· simp only [dif_neg i.property]

end type


variable {T : Î¹ â†’ Type*} -- subobject type
variable [Î  i, SetLike (T i) (R i)]
variable {A : Î  i, T i}

section monoid

@[to_additive]
def principalMulEquivProd [Î  i, Monoid (R i)] [âˆ€ i, SubmonoidClass (T i) (R i)] :
    Î Ê³ i, [R i, A i]_[ð“Ÿ S] â‰ƒ* (Î  i : {i // i âˆˆ S}, A i) Ã— (Î  i : {i // i âˆ‰ S}, R i) where
  __ := principalEquivProd R S _
  map_mul' _ _ := rfl

end monoid


end RestrictedProduct

section
variable {Î¹ : Type*}
variable {R : Î¹ â†’ Type*}
variable {â„± : Filter Î¹}

variable {T : Î¹ â†’ Type*} -- subobject type
variable [Î  i, SetLike (T i) (R i)]
--variable {B : Î  i, T i}

open scoped RestrictedProduct TensorProduct

variable {A : Type*} [CommRing A]



open Filter


noncomputable def RestrictedProduct.principal [Î  i, AddCommGroup (R i)]
    [âˆ€ i, Module A (R i)] {C : âˆ€ i, Submodule A (R i)}
    (S : Set Î¹) [âˆ€ i, Decidable (i âˆˆ S)] :
   (Î Ê³ i, [R i, C i]_[ð“Ÿ S]) â‰ƒâ‚—[A] ((Î  i : {i // i âˆˆ S}, C i) Ã—
  (Î  i : {i // i âˆ‰ S}, R i)) where
    __ := principalAddEquivSum R S (A := C)
    map_smul' m x := by
      simp only [AddEquiv.toEquiv_eq_coe, Equiv.toFun_as_coe, EquivLike.coe_coe, RingHom.id_apply]
      dsimp [principalAddEquivSum, principalEquivProd]
      ext i
      Â· simp only [Pi.smul_apply, SetLike.coe_sort_coe, SetLike.val_smul]
      Â· simp only [Pi.smul_apply]


noncomputable def RestrictedProduct.principal_tensor_comm' [Î  i, AddCommGroup (R i)]
    [âˆ€ i, Module A (R i)] {C : Î  i, Submodule A (R i)} {M : Type*} [AddCommGroup M] [Module A M]
    [Module.FinitePresentation A M] {S : Set Î¹} :
   M âŠ—[A] (Î Ê³ i, [R i, C i]_[ð“Ÿ S]) â‰ƒâ‚—[A] (Î Ê³ i, [M âŠ—[A] R i, (C i).lTensor M]_[ð“Ÿ S]) := sorry




-- this now compiles
noncomputable def RestrictedProduct.tensor_comm' [Î  i, AddCommGroup (R i)]
    [âˆ€ i, Module A (R i)] {C : Î  i, Submodule A (R i)}
    {M : Type*} [AddCommGroup M] [Module A M] [Module.FinitePresentation A M] [Module.Flat A M] :
    M âŠ—[A] (Î Ê³ i, [R i, C i]_[â„±]) â‰ƒâ‚—[A] Î Ê³ i, [M âŠ—[A] R i, (C i).lTensor M]_[â„±] :=
  LinearEquiv.ofBijective (TensorProduct.lift {
    toFun m := {
      toFun x := âŸ¨fun i â†¦ m âŠ—â‚œ (x i), Filter.Eventually.mono x.property (fun i hi â†¦
     LinearMap.mem_range.mpr âŸ¨m âŠ—â‚œ[A] âŸ¨x i, hiâŸ©, rflâŸ©)âŸ©
      map_add' x y := by
        ext i
        simp only [add_apply, mk_apply, TensorProduct.tmul_add]
      map_smul' a x := by
        ext i
        simp only [smul_apply, TensorProduct.tmul_smul, mk_apply, RingHom.id_apply]
    }
    map_add' x y := by
      refine LinearMap.ext (fun xâ‚ â†¦ ?_)
      ext i
      simp only [LinearMap.coe_mk, AddHom.coe_mk, mk_apply, LinearMap.add_apply, add_apply,
        TensorProduct.add_tmul]
    map_smul' a x := by
      refine LinearMap.ext (fun xâ‚ â†¦ ?_)
      ext i
      simp only [LinearMap.coe_mk, AddHom.coe_mk, mk_apply, RingHom.id_apply, LinearMap.smul_apply,
        smul_apply, TensorProduct.smul_tmul']
  }) âŸ¨
  fun a b h â†¦ by
    -- injectivity proof: if `a`, `b` in `M âŠ—[A] Î Ê³ (i : Î¹), [R i, â†‘(C i)]_[â„±]`
    -- and their images in `Î Ê³ (i : Î¹), [M âŠ—[A] R i, â†‘(Submodule.lTensor M (C i))]_[â„±]`
    -- are the same, then choose some `S âˆˆ â„±` such that `a`, `b` are both in
    -- `M âŠ— ((âˆ i âˆˆ S, C i) Ã— (âˆ i âˆ‰ S, R i))`, and then by your earlier work we know
    -- that the map from this to `(âˆ i âˆˆ S, M âŠ— C i) Ã— (âˆ i âˆ‰ S, M âŠ— R i)` is injective,
    -- and then by flatness the map from that to
    -- `Î Ê³ (i : Î¹), [M âŠ—[A] R i, â†‘(Submodule.lTensor M (C i))]_[â„±]` is injective,
    -- and `a` and `b` have become equal after the composite of those two injections,
    -- so they are equal.
    -- have h_finite : âˆƒ (S : Finset Î¹), S.toSet âˆˆ â„± âˆ§
    -- (âˆ€ x âˆˆ {a, b}, âˆƒ (f : Î¹ â†’ A), Set.finite {i | f i â‰  0} âˆ§
    --  âˆ€ i âˆ‰ S, (TensorProduct.lift _ x : _) i âˆˆ Submodule.lTensor M (C i)) := by
    --   sorry


    -- haveI {S: Set Î¹} {h: S âˆˆ â„±} : AddCommMonoid ((Î  i âˆˆ S, C i) Ã— (Î  i âˆ‰ S, R i)) := sorry
    -- have : âˆƒS âˆˆ â„±, a.val âˆˆ (M âŠ—[A] ((Î  i âˆˆ S, C i) Ã— (Î  i âˆ‰ S, R i))) âˆ§
    --   b.val âˆˆ (M âŠ—[A] ((Î  i âˆˆ S, C i) Ã— (Î  i âˆ‰ S, R i))) := sorry
    sorry,
  by
    intro y
    -- by definition `y âˆˆ (âˆ i âˆˆ S, â†‘(Submodule.lTensor M (C i))) Ã— (âˆ i âˆ‰ S, M âŠ— R i)`
    -- for some `S âˆˆ â„±`, and there's a surjection (in fact a bijection) from
    -- `(âˆ i âˆˆ S, M âŠ— (C i)) Ã— (âˆ i âˆ‰ S, M âŠ— R i)` onto this, and then by your earlier
    -- work there's something in `M âŠ— ((âˆ i âˆˆ S, C i) Ã— (âˆ i âˆ‰ S, R i))` which hits
    -- this, and the image of that thing in `M âŠ—[A] Î Ê³ (i : Î¹), [R i, â†‘(C i)]_[â„±]`
    -- will do
    sorryâŸ©




end

section
variable (A K L B : Type*) [CommRing A] [CommRing B] [Algebra A B] [Field K] [Field L]
    [Algebra A K] [IsFractionRing A K] [Algebra B L] [IsDedekindDomain A]
    [Algebra K L] [Algebra A L] [IsScalarTower A B L] [IsScalarTower A K L]
    [IsIntegralClosure B A L] [FiniteDimensional K L] [Module.Finite A B]
    [IsDedekindDomain B] [IsFractionRing B L]

variable (M : Type*) [AddCommGroup M] [Module A M] [Module.FinitePresentation A M]
namespace IsDedekindDomain

open IsDedekindDomain HeightOneSpectrum
#check Module.DirectLimit

noncomputable instance : DecidableEq (HeightOneSpectrum A) :=
  Classical.typeDecidableEq (HeightOneSpectrum A)


noncomputable def f (S T : Finset (HeightOneSpectrum A)) (h : S â‰¤ T) :
  ((Î  v : S, v.1.adicCompletion K) Ã—
  (Î  v : {v // v âˆ‰ S}, (adicCompletionIntegers K v.1))) â†’â‚—[A]
  ((Î  v : T, v.1.adicCompletion K) Ã—
  (Î  v : {v // v âˆ‰ T}, (adicCompletionIntegers K v.1))) where
    toFun x := (fun v â†¦
      if h' : (v : HeightOneSpectrum A) âˆˆ S then
        x.1 âŸ¨v, h'âŸ©
      else
        algebraMap _ _ (x.2 âŸ¨v, h'âŸ©),
     fun v â†¦ x.2 âŸ¨v, Set.notMem_subset h v.2âŸ©)
    map_add' x y := by
      simp only [Prod.fst_add, Pi.add_apply, Prod.snd_add, ValuationSubring.algebraMap_apply,
        AddMemClass.coe_add, Prod.mk_add_mk, Prod.mk.injEq]
      constructor
      Â· ext v
        by_cases hv : (v : HeightOneSpectrum A) âˆˆ S
        Â· simp [hv]
        Â· simp [hv]
      Â· ext v
        simp only [AddMemClass.coe_add, Pi.add_apply]
    map_smul' r x := by
      simp only [Prod.smul_fst, Pi.smul_apply, Prod.smul_snd, ValuationSubring.algebraMap_apply,
        coe_smul_adicCompletionIntegers, RingHom.id_apply, Prod.smul_mk, Prod.mk.injEq]
      constructor
      Â· ext v
        by_cases hv : (v : HeightOneSpectrum A) âˆˆ S
        Â· simp [hv]
        Â· simp [hv]
      Â· ext v
        simp only [coe_smul_adicCompletionIntegers, Pi.smul_apply]


noncomputable def direct_limit : (@Module.DirectLimit A _ (Finset (HeightOneSpectrum A)) _
  (fun S â†¦ ((Î  v : S, v.1.adicCompletion K) Ã— (Î  v : (Set.compl (Finset.toSet S)),
  (adicCompletionIntegers K v.1)))) _ _ (f A K) _) â‰ƒâ‚—[A] FiniteAdeleRing A K := by
  refine LinearEquiv.ofBijective (Module.DirectLimit.lift A (Finset (HeightOneSpectrum A))
    (fun S â†¦ ((Î  v : S, v.1.adicCompletion K) Ã— (Î  v : (Set.compl (Finset.toSet S)),
   (adicCompletionIntegers K v.1)))) (f A K) ?_ ?_) âŸ¨?_, ?_âŸ©
  Â· intro v
    simp only
    -- can rw as restricted product on princpal filter and go from there?
    sorry
  Â· intro v w
    sorry
  Â· apply Module.DirectLimit.lift_injective
    intro v

    sorry
  Â·
    sorry

end IsDedekindDomain


#exit



-- def G (S : Finset (HeightOneSpectrum A)):=
-- ((Î  v : S, v.1.adicCompletion K) Ã— (Î  v : (Set.compl (Finset.toSet S)), (adicCompletionIntegers K v.1)))

-- #check G A K

-- noncomputable instance (S : Finset (HeightOneSpectrum A)) : AddCommGroup (G A K S) :=
--   Prod.instAddCommGroup

-- instance (S : Finset (HeightOneSpectrum A)) : Module A (G A K S) := by
--   sorry

def DirectLimit' :=
  @Module.DirectLimit A _ (Finset (HeightOneSpectrum A)) _
  (fun S â†¦ ((Î  v : S, v.1.adicCompletion K) Ã— (Î  v : (Set.compl (Finset.toSet S)),
  (adicCompletionIntegers K v.1)))) _ _ (f A K) _

-- noncomputable def LHS (S : FiniteSubsets A) :=
--   M âŠ—[A] ((Î  v : S.val, adicCompletion K v.1) Ã—
--           (Î  v : (Set.compl S.val), adicCompletionIntegers K v.1))

-- noncomputable def RHS (S : FiniteSubsets A) :=
--   (Î  v : S.val, M âŠ—[A] adicCompletion K v.1) Ã—
--   (Î  v : (Set.compl S.val), M âŠ—[A] adicCompletionIntegers K v.1)

-- instance (S: FiniteSubsets A): AddCommMonoid (LHS A K M S) := by
--   dsimp [LHS]
--   exact TensorProduct.addCommMonoid

variable (iso : âˆ€ S : FiniteSubsets A, (M âŠ—[A] ((Î  v : S.val, adicCompletion K v.1) Ã—
          (Î  v : (Set.compl S.val), adicCompletionIntegers K v.1))) â‰ƒâ‚—[A]
          ((Î  v : S.val, M âŠ—[A] adicCompletion K v.1) Ã—
  (Î  v : (Set.compl S.val), M âŠ—[A] adicCompletionIntegers K v.1)))

let q : â„¤ := 1
def LHS_limit : Type* :=
  lim (fun S : FiniteSubsets => (M âŠ—[A] ((Î  v : S.val, adicCompletion K v.1) Ã—
          (Î  v : (Set.compl S.val), adicCompletionIntegers K v.1))))



end IsDedekindDomain
