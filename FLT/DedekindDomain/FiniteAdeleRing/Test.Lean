import FLT.Mathlib.Algebra.Algebra.Bilinear
import FLT.Mathlib.Algebra.Algebra.Pi
import FLT.Mathlib.Algebra.Module.Submodule.Basic
import FLT.Mathlib.NumberTheory.RamificationInertia.Basic
import FLT.Mathlib.Topology.Algebra.Module.Equiv
import FLT.Mathlib.Topology.Algebra.Module.ModuleTopology
import FLT.Mathlib.Topology.Algebra.UniformRing
import FLT.Mathlib.Topology.Algebra.Valued.ValuationTopology
import FLT.Mathlib.Topology.Algebra.Valued.WithVal
import FLT.Mathlib.RingTheory.TensorProduct.Basis
import FLT.Mathlib.RingTheory.Finiteness.Pi
import Mathlib.Algebra.Algebra.Subalgebra.Pi
import Mathlib.Algebra.BigOperators.Group.Finset.Basic
import Mathlib.Algebra.Group.Int.TypeTags
import Mathlib.Data.Int.WithZero
import Mathlib.RingTheory.DedekindDomain.FiniteAdeleRing
import Mathlib.Topology.Algebra.Algebra.Equiv
import Mathlib.Topology.Algebra.Module.ModuleTopology
import Mathlib.Topology.Algebra.Valued.NormedValued
import Mathlib.RingTheory.Valuation.RankOne
import Mathlib.Topology.Algebra.Module.FiniteDimension
import FLT.DedekindDomain.AdicValuation
import FLT.DedekindDomain.Completion.BaseChange
import FLT.Mathlib.Topology.Algebra.RestrictedProduct.Basic
import Mathlib.LinearAlgebra.TensorProduct.Prod
import Mathlib.Algebra.Colimit.Module
import Mathlib.RingTheory.Flat.Basic
import FLT.DedekindDomain.FiniteAdeleRing.TensorPi
import Mathlib.Order.DirectedInverseSystem




section IsDirectLimit

namespace Module

universe u

variable {R : Type*} [Semiring R] {Œπ : Type*} [Preorder Œπ] (M : Œπ ‚Üí Type*) (P : Type u)
variable [AddCommMonoid P] [Module R P]
variable [‚àÄ i, AddCommMonoid (M i)] [‚àÄ i, Module R (M i)] (f : ‚àÄ i j, i ‚â§ j ‚Üí M i ‚Üí‚Çó[R] M j)
variable (g : ‚àÄ i, M i ‚Üí‚Çó[R] P) (Hg : ‚àÄ i j hij x, g j (f i j hij x) = g i x)
variable [DecidableEq Œπ] [IsDirected Œπ (¬∑ ‚â§ ¬∑)] [Nonempty Œπ] [DirectedSystem M (f ¬∑ ¬∑ ¬∑)]

@[mk_iff] class IsDirectLimit : Prop where
  compatibility : ‚àÄ i j hij x, g j (f i j hij x) = g i x
  universal_property :
    ‚àÄ {X : Type u} [AddCommMonoid X] [Module R X],
    ‚àÄ gX : ‚àÄ i, M i ‚Üí‚Çó[R] X, ‚àÄ _ : ‚àÄ i j hij x, gX j (f i j hij x) = gX i x,
    ‚àÉ! œÜ : P ‚Üí‚Çó[R] X, ‚àÄ i x, œÜ (g i x) = gX i x

instance isDirectLimit :
    IsDirectLimit M (Module.DirectLimit M f) f
    (Module.DirectLimit.of R Œπ M f) where
  compatibility i j hij x := Module.DirectLimit.of_f
  universal_property gX HgX :=
    ‚ü®Module.DirectLimit.lift R Œπ M f gX HgX,
      by simp,
      by
        intro y hy
        ext x
        convert Module.DirectLimit.lift_unique y x with i
        ext x'
        simp only [LinearMap.coe_comp, Function.comp_apply]
        exact (hy i x').symm‚ü©

section Iso

theorem universal_prop_identity [h : IsDirectLimit M P f g] :
  (h.universal_property g h.compatibility).exists.choose = LinearMap.id := by
  apply ExistsUnique.unique (h.universal_property g h.compatibility)
  ¬∑ exact (h.universal_property g h.compatibility).exists.choose_spec
  ¬∑ simp only [LinearMap.id_coe, id_eq, implies_true]

#check Submodule.mkQ
theorem IsDirectLimit.surj' [h : IsDirectLimit M P f g] : ‚àÄ m : P, ‚àÉ i, ‚àÉ mi : M i, g i mi = m := by
  intro m
  let Q : Submodule R P := Submodule.span R (‚ãÉ i, Set.range (g i))


  sorry

variable (P‚ÇÅ P‚ÇÇ : Type u) [AddCommMonoid P‚ÇÅ] [Module R P‚ÇÅ] [AddCommMonoid P‚ÇÇ] [Module R P‚ÇÇ]
variable (g‚ÇÅ : ‚àÄ i, M i ‚Üí‚Çó[R] P‚ÇÅ)
variable (g‚ÇÇ : ‚àÄ i, M i ‚Üí‚Çó[R] P‚ÇÇ)

set_option pp.proofs true in
noncomputable def iso_of_isDirectLimit
    [h‚ÇÅ : IsDirectLimit M P‚ÇÅ f g‚ÇÅ] [h‚ÇÇ : IsDirectLimit M P‚ÇÇ f g‚ÇÇ] :
    P‚ÇÅ ‚âÉ‚Çó[R] P‚ÇÇ where
  __ := (h‚ÇÅ.universal_property g‚ÇÇ h‚ÇÇ.compatibility).exists.choose
  invFun := (h‚ÇÇ.universal_property g‚ÇÅ h‚ÇÅ.compatibility).exists.choose
  left_inv := by
    simp only [AddHom.toFun_eq_coe, LinearMap.coe_toAddHom]
    refine Function.leftInverse_iff_comp.mpr ?_
    rw [‚Üê LinearMap.coe_comp, ‚Üê LinearMap.id_coe (R:=R)]
    refine DFunLike.coe_fn_eq.mpr
      (ExistsUnique.unique (h‚ÇÅ.universal_property g‚ÇÅ h‚ÇÅ.compatibility) ?_ ?_)
    ¬∑ intro i mi
      simp only [LinearMap.coe_comp, Function.comp_apply]
      rw [(ExistsUnique.exists (h‚ÇÅ.universal_property g‚ÇÇ h‚ÇÇ.compatibility)).choose_spec i mi,
        (ExistsUnique.exists (h‚ÇÇ.universal_property g‚ÇÅ h‚ÇÅ.compatibility)).choose_spec i mi]
    ¬∑ intro i mi
      simp only [LinearMap.id_coe, id_eq]
  right_inv := by
    simp only [AddHom.toFun_eq_coe, LinearMap.coe_toAddHom]
    refine Function.rightInverse_iff_comp.mpr ?_
    rw [‚Üê LinearMap.coe_comp, ‚Üê LinearMap.id_coe (R:=R)]
    refine DFunLike.coe_fn_eq.mpr
      (ExistsUnique.unique (h‚ÇÇ.universal_property g‚ÇÇ h‚ÇÇ.compatibility) ?_ ?_)
    ¬∑ intro i mi
      simp only [LinearMap.coe_comp, Function.comp_apply]
      rw [(ExistsUnique.exists (h‚ÇÇ.universal_property g‚ÇÅ h‚ÇÅ.compatibility)).choose_spec i mi,
        (ExistsUnique.exists (h‚ÇÅ.universal_property g‚ÇÇ h‚ÇÇ.compatibility)).choose_spec i mi]
    ¬∑ intro i mi
      simp only [LinearMap.id_coe, id_eq]

end Iso

end Module

end IsDirectLimit

section IsDirectLimit

namespace Module

variable {R : Type*} [Semiring R] {Œπ : Type*} [Preorder Œπ] (M : Œπ ‚Üí Type*) (P : Type*)
variable [AddCommMonoid P] [Module R P]
variable [‚àÄ i, AddCommMonoid (M i)] [‚àÄ i, Module R (M i)] (f : ‚àÄ i j, i ‚â§ j ‚Üí M i ‚Üí‚Çó[R] M j)
variable (g : ‚àÄ i, M i ‚Üí‚Çó[R] P) (Hg : ‚àÄ i j hij x, g j (f i j hij x) = g i x)
variable [DecidableEq Œπ] [IsDirected Œπ (¬∑ ‚â§ ¬∑)] [Nonempty Œπ] [DirectedSystem M (f ¬∑ ¬∑ ¬∑)]

@[mk_iff] class IsDirectLimit' : Prop where
  surj : ‚àÄ m : P, ‚àÉ i, ‚àÉ mi : M i, g i mi = m
  inj :  ‚àÄ i j, ‚àÄ mi : M i, ‚àÄ mj : M j, g i mi = g j mj ‚Üí ‚àÉ (k : Œπ) (hik : i ‚â§ k) (hjk : j ‚â§ k),
      f i k hik mi = f j k hjk mj

variable [IsDirectLimit M P f g]


instance isDirectLimit' : IsDirectLimit' M (Module.DirectLimit M f) f
  (Module.DirectLimit.of R Œπ M f) where
  surj := Module.DirectLimit.exists_of
  inj i j mi mj h := by
    apply_fun Module.DirectLimit.linearEquiv _ _ at h
    simp_rw [Module.DirectLimit.linearEquiv_of] at h

    have ‚ü®k, hi, hj, hij‚ü© := Quotient.exact h
    exact ‚ü®k, hi, hj, hij‚ü©




-- set_option pp.proofs true in
-- noncomputable def iso : Module.DirectLimit M f ‚âÉ‚Çó[R] P where
--   __ := Module.DirectLimit.lift R Œπ M f g Hg
--   invFun p := by
--     set j := Classical.choose (IsDirectLimit.surj' M P f g p)
--     set mj := (Classical.choose (Classical.choose_spec (IsDirectLimit.surj' M P f g p)))
--     exact Module.DirectLimit.of R Œπ M f j mj
--   left_inv x := by
--     simp only [AddHom.toFun_eq_coe, LinearMap.coe_toAddHom]

--     obtain ‚ü®i, mi, hmi‚ü© := IsDirectLimit'.surj f (g := (Module.DirectLimit.of R Œπ M f)) x
--     rw [‚Üê hmi]
--     simp only [DirectLimit.lift_of]
--     apply_fun Module.DirectLimit.linearEquiv _ _
--     simp_rw [Module.DirectLimit.linearEquiv_of]
--     simp only [Quotient.eq]





--     sorry
--   right_inv p := by
--     simp only [AddHom.toFun_eq_coe, LinearMap.coe_toAddHom, DirectLimit.lift_of]
--     exact Classical.choose_spec (Classical.choose_spec (IsDirectLimit.surj' M P f g p))


end Module

end IsDirectLimit

section TensorProduct

open scoped TensorProduct
open Module

variable {R : Type*} [CommSemiring R] {Œπ : Type*} [Preorder Œπ] (M : Œπ ‚Üí Type*) (P : Type*)
variable [AddCommMonoid P] [Module R P]
variable [‚àÄ i, AddCommMonoid (M i)] [‚àÄ i, Module R (M i)] (f : ‚àÄ i j, i ‚â§ j ‚Üí M i ‚Üí‚Çó[R] M j)
variable (g : ‚àÄ i, M i ‚Üí‚Çó[R] P) (Hg : ‚àÄ i j hij x, g j (f i j hij x) = g i x)
variable [DecidableEq Œπ] [IsDirected Œπ (¬∑ ‚â§ ¬∑)] [Nonempty Œπ] [DirectedSystem M (f ¬∑ ¬∑ ¬∑)]
variable (N : Type*) [AddCommMonoid N] [Module R N] [IsDirectLimit M P f g]

def incTensorMap (i j : Œπ) (h : i ‚â§ j) : M i ‚äó[R] N ‚Üí‚Çó[R] M j ‚äó[R] N :=
   TensorProduct.map (f i j h) (LinearMap.id)

def tensorMap (i : Œπ) : M i ‚äó[R] N ‚Üí‚Çó[R] P ‚äó[R] N :=
  TensorProduct.map (g i) (LinearMap.id)

instance : IsDirectLimit (fun i ‚Ü¶ (M i ‚äó[R] N)) (P ‚äó[R] N) (incTensorMap M f N)
  (tensorMap M P g N) := sorry

instance : DirectedSystem (fun i ‚Ü¶ M i ‚äó[R] N) fun x1 x2 x3 ‚Ü¶ ‚áë(incTensorMap M f N x1 x2 x3) :=
  sorry

#check (Module.iso_of_isDirectLimit (fun i ‚Ü¶ (M i ‚äó[R] N)) (incTensorMap M f N)
 (Module.DirectLimit (fun i ‚Ü¶ (M i ‚äó[R] N)) (incTensorMap M f N)) (P ‚äó[R] N)
 (Module.DirectLimit.of R Œπ (fun i ‚Ü¶ (M i ‚äó[R] N)) (incTensorMap M f N)) (tensorMap M P g N))

include g in
noncomputable def iso' :
  (Module.DirectLimit (fun i ‚Ü¶ (M i ‚äó[R] N)) (incTensorMap M f N)) ‚âÉ‚Çó[R] (P ‚äó[R] N) := by
  haveI : DirectedSystem (fun i ‚Ü¶ M i ‚äó[R] N) fun x1 x2 x3 ‚Ü¶ ‚áë(incTensorMap M f N x1 x2 x3) := sorry
  apply (Module.iso_of_isDirectLimit (fun i ‚Ü¶ (M i ‚äó[R] N)) (incTensorMap M f N)
    (Module.DirectLimit (fun i ‚Ü¶ (M i ‚äó[R] N)) (incTensorMap M f N)) (P ‚äó[R] N)
    (Module.DirectLimit.of R Œπ (fun i ‚Ü¶ (M i ‚äó[R] N)) (incTensorMap M f N)) (tensorMap M P g N))



instance : IsDirectLimit (fun i ‚Ü¶ (M i ‚äó[R] N))
  (Module.DirectLimit (fun i ‚Ü¶ (M i ‚äó[R] N)) (incTensorMap M f N))
  (incTensorMap M f N) (Module.DirectLimit.of R Œπ M f) := sorry




end TensorProduct



section RestrictedProduct



open Set Filter

variable {Œπ : Type*} {ùìï : Filter Œπ}

variable (ùìï) in
/-- The complements of sets in a `Filter`.
E.g. for the cofinite filter, these are just the finite subsets. -/
def Filter.complement : Set (Set Œπ) := (fun S => S·∂ú) '' ùìï.sets

theorem principal_filter_order {S‚ÇÅ S‚ÇÇ : ùìï.complement} (h : S‚ÇÅ ‚â§ S‚ÇÇ) :
    (ùìü S‚ÇÇ·∂ú : Filter Œπ) ‚â§ ùìü S‚ÇÅ·∂ú := by
  simp only [le_principal_iff, mem_principal, compl_subset_compl]; exact h

theorem filter_bot :
    ‚àÄ S : ùìï.complement, ùìï ‚â§ (ùìü S·∂ú : Filter Œπ) := by
  intro S
  simp only [le_principal_iff]
  refine Filter.mem_sets.mp ?_
  have h : ùìï.sets = (fun S => S·∂ú) '' (ùìï.complement) := by
    rw[complement]
    exact Eq.symm (compl_compl_image ùìï.sets)
  rw[h]
  simp

open scoped RestrictedProduct

variable {R : Œπ ‚Üí Type*} {A : (i : Œπ) ‚Üí Set (R i)}

variable (A) in
/-- This is (isomorphic to) `(Œ† i ‚àà S, R i) √ó (Œ† i ‚àâ S, A i)` -/
def mem_A_away_from_S (S : ùìï.complement) : Type _ :=
  Œ† ≥ i, [R i, A i]_[ùìü S·∂ú]

/-- The inclusions between `mem_A_away_from_S` which will form the directed system. -/
def inclusion (S‚ÇÅ S‚ÇÇ : ùìï.complement) (h : S‚ÇÅ ‚â§ S‚ÇÇ) :
    mem_A_away_from_S A S‚ÇÅ ‚Üí mem_A_away_from_S A S‚ÇÇ :=
  RestrictedProduct.inclusion _ _ (principal_filter_order h)

instance directed_system :
    @DirectedSystem (ùìï.complement) _ (mem_A_away_from_S A) (inclusion) where
  map_self _ _ := rfl
  map_map _ _ _ _ _ _ := rfl

/-- The maps from the directed system to the actual restricted product. -/
def inclusion_to_restrictedProduct (S : ùìï.complement) :
    mem_A_away_from_S A S ‚Üí Œ† ≥ i, [R i, A i]_[ùìï] :=
  RestrictedProduct.inclusion _ _ (filter_bot S)

-- ....


end RestrictedProduct



variable {Œπ : Type*} {R : Œπ ‚Üí Type*} {‚Ñ± : Filter Œπ}

variable {T : Œπ ‚Üí Type*} -- subobject type
variable [Œ† i, SetLike (T i) (R i)]
variable {B : Œ† i, T i}

open scoped RestrictedProduct TensorProduct Module.IsDirectLimit

variable {A : Type*} [CommRing A]

-- In open PR #25715
-- restricted product of addcommgroups is an addcommgroup
instance [Œ† i, AddCommGroup (R i)] [‚àÄ i, AddSubgroupClass (T i) (R i)] :
    AddCommGroup (Œ† ≥ i, [R i, B i]_[‚Ñ±]) where
  __ := inferInstanceAs (AddGroup (Œ† ≥ i, [R i, B i]_[‚Ñ±]))
  add_comm a b := by ext i; simp [add_comm]

-- when #25715 lands we'll be able to change these to AddCommMonoid
-- restricted product of A-modules is an A-module
instance module [Œ† i, AddCommGroup (R i)] [‚àÄ i, Module A (R i)]
    -- next line is how we do "SubmoduleClass"
    [‚àÄ i, AddSubgroupClass (T i) (R i)] [‚àÄ i, SMulMemClass (T i) A (R i)] :
    Module A (Œ† ≥ i, [R i, B i]_[‚Ñ±]) where
      smul a x := ‚ü®fun i ‚Ü¶ a ‚Ä¢ x i, Filter.Eventually.mono x.property (fun _ hi ‚Ü¶
     SMulMemClass.smul_mem a hi)‚ü©
      one_smul b := by ext; simp
      mul_smul x y b := by ext; simp [mul_smul]
      smul_zero b := by ext; simp
      smul_add x a b := by ext; simp
      add_smul a b x := by
        ext
        simp only [RestrictedProduct.smul_apply, RestrictedProduct.add_apply, add_smul]
      zero_smul b := by ext; simp

noncomputable def Submodule.lTensor (M : Type*) {N : Type*} [AddCommGroup M] [Module A M]
    [AddCommGroup N] [Module A N] (P : Submodule A N) : Submodule A (M ‚äó[A] N) :=
  LinearMap.range (P.subtype.lTensor M)


variable {Œπ : Type*} {R : Œπ ‚Üí Type*} {‚Ñ± : Filter Œπ} [Preorder Œπ]

variable {T : Œπ ‚Üí Type*} -- subobject type
variable [Œ† i, SetLike (T i) (R i)]
variable {B : Œ† i, T i}
variable {A : Type*} [CommRing A]

variable [Œ† i, AddCommGroup (R i)] [‚àÄ i, Module A (R i)] {C : ‚àÄ i, Submodule A (R i)}
{M : Type*} [AddCommGroup M] [Module A M] [Module.FinitePresentation A M] (S : Filter.complement ‚Ñ±)

open Set Filter RestrictedProduct

instance add (S : ‚Ñ±.complement) :
  AddCommMonoid (mem_A_away_from_S (fun i ‚Ü¶ (C i : Set (R i))) S) := by
  dsimp [mem_A_away_from_S]
  exact AddCommGroup.toDivisionAddCommMonoid.toAddCommMonoid

instance module' (S : ‚Ñ±.complement) :
  Module A (mem_A_away_from_S (fun i ‚Ü¶ (C i : Set (R i))) S) := by
  dsimp [mem_A_away_from_S]
  exact module


def inclusion_module (S‚ÇÅ S‚ÇÇ : ‚Ñ±.complement) (h : S‚ÇÅ ‚â§ S‚ÇÇ) :
    mem_A_away_from_S (fun i ‚Ü¶ (C i : Set (R i))) S‚ÇÅ ‚Üí‚Çó[A]
      mem_A_away_from_S ((fun i ‚Ü¶ (C i : Set (R i)))) S‚ÇÇ where
  toFun := inclusion S‚ÇÅ S‚ÇÇ h
  map_add' _ _ := rfl
  map_smul' _ _ := rfl


def inclusion_to_restricted_product_module (S : ‚Ñ±.complement) :
  mem_A_away_from_S (fun i ‚Ü¶ (C i : Set (R i))) S ‚Üí‚Çó[A] Œ† ≥ i, [R i, C i]_[‚Ñ±] where
  toFun := inclusion_to_restrictedProduct S
  map_add' _ _ := rfl
  map_smul' _ _ := rfl


instance directed : IsDirected (‚Ñ±.complement) (¬∑ ‚â§ ¬∑) := by
  refine { directed := ?_ }
  intro Si Sj
  obtain ‚ü®Si, hi‚ü© := Si
  obtain ‚ü®Sj, hj‚ü© := Sj
  let c := Si ‚à™ Sj
  have : c ‚àà ‚Ñ±.complement := by
    unfold Filter.complement at hi hj ‚ä¢
    simp only [mem_image, Filter.mem_sets] at hi hj ‚ä¢
    obtain ‚ü®si, hsi‚ü© := hi
    obtain ‚ü®sj, hsj‚ü© := hj
    use si ‚à© sj
    constructor
    ¬∑ exact ‚Ñ±.inter_sets hsi.1 hsj.1
    ¬∑ unfold c
      rw [compl_inter, hsi.2, hsj.2]
  use ‚ü®c, this‚ü©
  constructor <;>
  simp [c]

open Set
instance RestrictedProductIsDirectLimit :
  Module.IsDirectLimit (mem_A_away_from_S  (fun i ‚Ü¶ (C i : Set (R i))))
  Œ† ≥ i, [R i, C i]_[‚Ñ±] (inclusion_module (‚Ñ± := ‚Ñ±))
  (inclusion_to_restricted_product_module ) where
  inj S·µ¢ S‚±º mi mj hmij := by
    obtain ‚ü®S‚Çñ, hik, hjk‚ü© := @directed_of _ (¬∑ ‚â§ ¬∑) directed S·µ¢ S‚±º
    refine ‚ü®S‚Çñ, hik, hjk, ?_‚ü©
    dsimp [inclusion_module,_root_.inclusion, RestrictedProduct.inclusion]
    dsimp [inclusion_to_restricted_product_module, inclusion_to_restrictedProduct,
      RestrictedProduct.inclusion] at hmij
    apply Subtype.ext
    simp only
    injection hmij
  surj r := by
    dsimp [inclusion_to_restricted_product_module, inclusion_to_restrictedProduct]
    have : ‚àÖ ‚àà ‚Ñ±.complement := by
      rw [complement]
      simp only [mem_image, Filter.mem_sets, compl_empty_iff, exists_eq_right, univ_mem]
    let b:= r.property
    let c:= r.1
    have : { i : Œπ | r.1 i ‚àà (C i : Set (R i)) }·∂ú ‚àà ‚Ñ±.complement := by
      rw [complement]
      simp only [mem_image, Filter.mem_sets]
      refine ‚ü®{ i : Œπ | r.1 i ‚àà (C i : Set (R i)) }, r.property, ?_‚ü©
      rfl
    use ‚ü®{ i : Œπ | r.1 i ‚àà (C i : Set (R i)) }·∂ú, this‚ü©
    apply RestrictedProduct.exists_inclusion_eq_of_eventually
    simp only [SetLike.mem_coe, compl_compl, eventually_principal, mem_setOf_eq]
    exact fun x a ‚Ü¶ a





variable {Œπ : Type*} (R : Œπ ‚Üí Type*) (S : Set Œπ) [‚àÄ i, Decidable (i ‚àà S)]

open scoped Filter

namespace RestrictedProduct

section type

variable (A : (i : Œπ) ‚Üí Set (R i))

def principalEquivProd : Œ† ≥ i, [R i, A i]_[ùìü S] ‚âÉ
    (Œ† i : {i // i ‚àà S}, A i) √ó (Œ† i : {i // i ‚àâ S}, R i) where
  toFun x := (fun i ‚Ü¶ ‚ü®x i, x.property i.property‚ü©, fun i ‚Ü¶ x i)
  invFun y := ‚ü®fun i ‚Ü¶ if hi : i ‚àà S then y.1 ‚ü®i, hi‚ü© else y.2 ‚ü®i, hi‚ü©,
  Filter.eventually_principal.mpr (fun i hi ‚Ü¶ by simp only [hi]; exact (y.1 ‚ü®i, hi‚ü©).2)‚ü©
  left_inv x := by
    simp only [dite_eq_ite, ite_self]
    rfl
  right_inv x := by
    simp only [mk_apply, Subtype.coe_prop, ‚ÜìreduceDIte, Subtype.coe_eta]
    ext i
    ¬∑ rfl
    ¬∑ simp only [dif_neg i.property]

end type


variable {T : Œπ ‚Üí Type*} -- subobject type
variable [Œ† i, SetLike (T i) (R i)]
variable {A : Œ† i, T i}

section monoid

@[to_additive]
def principalMulEquivProd [Œ† i, Monoid (R i)] [‚àÄ i, SubmonoidClass (T i) (R i)] :
    Œ† ≥ i, [R i, A i]_[ùìü S] ‚âÉ* (Œ† i : {i // i ‚àà S}, A i) √ó (Œ† i : {i // i ‚àâ S}, R i) where
  __ := principalEquivProd R S _
  map_mul' _ _ := rfl

end monoid


end RestrictedProduct

section
variable {Œπ : Type*}
variable {R : Œπ ‚Üí Type*}
variable {‚Ñ± : Filter Œπ}

variable {T : Œπ ‚Üí Type*} -- subobject type
variable [Œ† i, SetLike (T i) (R i)]
--variable {B : Œ† i, T i}

open scoped RestrictedProduct TensorProduct

variable {A : Type*} [CommRing A]



open Filter


noncomputable def RestrictedProduct.principal [Œ† i, AddCommGroup (R i)]
    [‚àÄ i, Module A (R i)] {C : ‚àÄ i, Submodule A (R i)}
    (S : Set Œπ) [‚àÄ i, Decidable (i ‚àà S)] :
   (Œ† ≥ i, [R i, C i]_[ùìü S]) ‚âÉ‚Çó[A] ((Œ† i : {i // i ‚àà S}, C i) √ó
  (Œ† i : {i // i ‚àâ S}, R i)) where
    __ := principalAddEquivSum R S (A := C)
    map_smul' m x := by
      simp only [AddEquiv.toEquiv_eq_coe, Equiv.toFun_as_coe, EquivLike.coe_coe, RingHom.id_apply]
      dsimp [principalAddEquivSum, principalEquivProd]
      ext i
      ¬∑ simp only [Pi.smul_apply, SetLike.coe_sort_coe, SetLike.val_smul]
      ¬∑ simp only [Pi.smul_apply]


noncomputable def RestrictedProduct.principal_tensor_comm' [Œ† i, AddCommGroup (R i)]
    [‚àÄ i, Module A (R i)] {C : Œ† i, Submodule A (R i)} {M : Type*} [AddCommGroup M] [Module A M]
    [Module.FinitePresentation A M] {S : Set Œπ} :
   M ‚äó[A] (Œ† ≥ i, [R i, C i]_[ùìü S]) ‚âÉ‚Çó[A] (Œ† ≥ i, [M ‚äó[A] R i, (C i).lTensor M]_[ùìü S]) := sorry




-- this now compiles
noncomputable def RestrictedProduct.tensor_comm' [Œ† i, AddCommGroup (R i)]
    [‚àÄ i, Module A (R i)] {C : Œ† i, Submodule A (R i)}
    {M : Type*} [AddCommGroup M] [Module A M] [Module.FinitePresentation A M] [Module.Flat A M] :
    M ‚äó[A] (Œ† ≥ i, [R i, C i]_[‚Ñ±]) ‚âÉ‚Çó[A] Œ† ≥ i, [M ‚äó[A] R i, (C i).lTensor M]_[‚Ñ±] :=
  LinearEquiv.ofBijective (TensorProduct.lift {
    toFun m := {
      toFun x := ‚ü®fun i ‚Ü¶ m ‚äó‚Çú (x i), Filter.Eventually.mono x.property (fun i hi ‚Ü¶
     LinearMap.mem_range.mpr ‚ü®m ‚äó‚Çú[A] ‚ü®x i, hi‚ü©, rfl‚ü©)‚ü©
      map_add' x y := by
        ext i
        simp only [add_apply, mk_apply, TensorProduct.tmul_add]
      map_smul' a x := by
        ext i
        simp only [smul_apply, TensorProduct.tmul_smul, mk_apply, RingHom.id_apply]
    }
    map_add' x y := by
      refine LinearMap.ext (fun x‚ÇÅ ‚Ü¶ ?_)
      ext i
      simp only [LinearMap.coe_mk, AddHom.coe_mk, mk_apply, LinearMap.add_apply, add_apply,
        TensorProduct.add_tmul]
    map_smul' a x := by
      refine LinearMap.ext (fun x‚ÇÅ ‚Ü¶ ?_)
      ext i
      simp only [LinearMap.coe_mk, AddHom.coe_mk, mk_apply, RingHom.id_apply, LinearMap.smul_apply,
        smul_apply, TensorProduct.smul_tmul']
  }) ‚ü®
  fun a b h ‚Ü¶ by
    -- injectivity proof: if `a`, `b` in `M ‚äó[A] Œ† ≥ (i : Œπ), [R i, ‚Üë(C i)]_[‚Ñ±]`
    -- and their images in `Œ† ≥ (i : Œπ), [M ‚äó[A] R i, ‚Üë(Submodule.lTensor M (C i))]_[‚Ñ±]`
    -- are the same, then choose some `S ‚àà ‚Ñ±` such that `a`, `b` are both in
    -- `M ‚äó ((‚àè i ‚àà S, C i) √ó (‚àè i ‚àâ S, R i))`, and then by your earlier work we know
    -- that the map from this to `(‚àè i ‚àà S, M ‚äó C i) √ó (‚àè i ‚àâ S, M ‚äó R i)` is injective,
    -- and then by flatness the map from that to
    -- `Œ† ≥ (i : Œπ), [M ‚äó[A] R i, ‚Üë(Submodule.lTensor M (C i))]_[‚Ñ±]` is injective,
    -- and `a` and `b` have become equal after the composite of those two injections,
    -- so they are equal.
    -- have h_finite : ‚àÉ (S : Finset Œπ), S.toSet ‚àà ‚Ñ± ‚àß
    -- (‚àÄ x ‚àà {a, b}, ‚àÉ (f : Œπ ‚Üí A), Set.finite {i | f i ‚â† 0} ‚àß
    --  ‚àÄ i ‚àâ S, (TensorProduct.lift _ x : _) i ‚àà Submodule.lTensor M (C i)) := by
    --   sorry


    -- haveI {S: Set Œπ} {h: S ‚àà ‚Ñ±} : AddCommMonoid ((Œ† i ‚àà S, C i) √ó (Œ† i ‚àâ S, R i)) := sorry
    -- have : ‚àÉS ‚àà ‚Ñ±, a.val ‚àà (M ‚äó[A] ((Œ† i ‚àà S, C i) √ó (Œ† i ‚àâ S, R i))) ‚àß
    --   b.val ‚àà (M ‚äó[A] ((Œ† i ‚àà S, C i) √ó (Œ† i ‚àâ S, R i))) := sorry
    sorry,
  by
    intro y
    -- by definition `y ‚àà (‚àè i ‚àà S, ‚Üë(Submodule.lTensor M (C i))) √ó (‚àè i ‚àâ S, M ‚äó R i)`
    -- for some `S ‚àà ‚Ñ±`, and there's a surjection (in fact a bijection) from
    -- `(‚àè i ‚àà S, M ‚äó (C i)) √ó (‚àè i ‚àâ S, M ‚äó R i)` onto this, and then by your earlier
    -- work there's something in `M ‚äó ((‚àè i ‚àà S, C i) √ó (‚àè i ‚àâ S, R i))` which hits
    -- this, and the image of that thing in `M ‚äó[A] Œ† ≥ (i : Œπ), [R i, ‚Üë(C i)]_[‚Ñ±]`
    -- will do
    sorry‚ü©




end

section
variable (A K L B : Type*) [CommRing A] [CommRing B] [Algebra A B] [Field K] [Field L]
    [Algebra A K] [IsFractionRing A K] [Algebra B L] [IsDedekindDomain A]
    [Algebra K L] [Algebra A L] [IsScalarTower A B L] [IsScalarTower A K L]
    [IsIntegralClosure B A L] [FiniteDimensional K L] [Module.Finite A B]
    [IsDedekindDomain B] [IsFractionRing B L]

variable (M : Type*) [AddCommGroup M] [Module A M] [Module.FinitePresentation A M]
namespace IsDedekindDomain

open IsDedekindDomain HeightOneSpectrum
#check Module.DirectLimit

noncomputable instance : DecidableEq (HeightOneSpectrum A) :=
  Classical.typeDecidableEq (HeightOneSpectrum A)


noncomputable def f (S T : Finset (HeightOneSpectrum A)) (h : S ‚â§ T) :
  ((Œ† v : S, v.1.adicCompletion K) √ó
  (Œ† v : {v // v ‚àâ S}, (adicCompletionIntegers K v.1))) ‚Üí‚Çó[A]
  ((Œ† v : T, v.1.adicCompletion K) √ó
  (Œ† v : {v // v ‚àâ T}, (adicCompletionIntegers K v.1))) where
    toFun x := (fun v ‚Ü¶
      if h' : (v : HeightOneSpectrum A) ‚àà S then
        x.1 ‚ü®v, h'‚ü©
      else
        algebraMap _ _ (x.2 ‚ü®v, h'‚ü©),
     fun v ‚Ü¶ x.2 ‚ü®v, Set.notMem_subset h v.2‚ü©)
    map_add' x y := by
      simp only [Prod.fst_add, Pi.add_apply, Prod.snd_add, ValuationSubring.algebraMap_apply,
        AddMemClass.coe_add, Prod.mk_add_mk, Prod.mk.injEq]
      constructor
      ¬∑ ext v
        by_cases hv : (v : HeightOneSpectrum A) ‚àà S
        ¬∑ simp [hv]
        ¬∑ simp [hv]
      ¬∑ ext v
        simp only [AddMemClass.coe_add, Pi.add_apply]
    map_smul' r x := by
      simp only [Prod.smul_fst, Pi.smul_apply, Prod.smul_snd, ValuationSubring.algebraMap_apply,
        coe_smul_adicCompletionIntegers, RingHom.id_apply, Prod.smul_mk, Prod.mk.injEq]
      constructor
      ¬∑ ext v
        by_cases hv : (v : HeightOneSpectrum A) ‚àà S
        ¬∑ simp [hv]
        ¬∑ simp [hv]
      ¬∑ ext v
        simp only [coe_smul_adicCompletionIntegers, Pi.smul_apply]


noncomputable def direct_limit : (@Module.DirectLimit A _ (Finset (HeightOneSpectrum A)) _
  (fun S ‚Ü¶ ((Œ† v : S, v.1.adicCompletion K) √ó (Œ† v : (Set.compl (Finset.toSet S)),
  (adicCompletionIntegers K v.1)))) _ _ (f A K) _) ‚âÉ‚Çó[A] FiniteAdeleRing A K := by
  refine LinearEquiv.ofBijective (Module.DirectLimit.lift A (Finset (HeightOneSpectrum A))
    (fun S ‚Ü¶ ((Œ† v : S, v.1.adicCompletion K) √ó (Œ† v : (Set.compl (Finset.toSet S)),
   (adicCompletionIntegers K v.1)))) (f A K) ?_ ?_) ‚ü®?_, ?_‚ü©
  ¬∑ intro v
    simp only
    -- can rw as restricted product on princpal filter and go from there?
    sorry
  ¬∑ intro v w
    sorry
  ¬∑ apply Module.DirectLimit.lift_injective
    intro v

    sorry
  ¬∑
    sorry

end IsDedekindDomain


#exit



-- def G (S : Finset (HeightOneSpectrum A)):=
-- ((Œ† v : S, v.1.adicCompletion K) √ó (Œ† v : (Set.compl (Finset.toSet S)), (adicCompletionIntegers K v.1)))

-- #check G A K

-- noncomputable instance (S : Finset (HeightOneSpectrum A)) : AddCommGroup (G A K S) :=
--   Prod.instAddCommGroup

-- instance (S : Finset (HeightOneSpectrum A)) : Module A (G A K S) := by
--   sorry

def DirectLimit' :=
  @Module.DirectLimit A _ (Finset (HeightOneSpectrum A)) _
  (fun S ‚Ü¶ ((Œ† v : S, v.1.adicCompletion K) √ó (Œ† v : (Set.compl (Finset.toSet S)),
  (adicCompletionIntegers K v.1)))) _ _ (f A K) _

-- noncomputable def LHS (S : FiniteSubsets A) :=
--   M ‚äó[A] ((Œ† v : S.val, adicCompletion K v.1) √ó
--           (Œ† v : (Set.compl S.val), adicCompletionIntegers K v.1))

-- noncomputable def RHS (S : FiniteSubsets A) :=
--   (Œ† v : S.val, M ‚äó[A] adicCompletion K v.1) √ó
--   (Œ† v : (Set.compl S.val), M ‚äó[A] adicCompletionIntegers K v.1)

-- instance (S: FiniteSubsets A): AddCommMonoid (LHS A K M S) := by
--   dsimp [LHS]
--   exact TensorProduct.addCommMonoid

variable (iso : ‚àÄ S : FiniteSubsets A, (M ‚äó[A] ((Œ† v : S.val, adicCompletion K v.1) √ó
          (Œ† v : (Set.compl S.val), adicCompletionIntegers K v.1))) ‚âÉ‚Çó[A]
          ((Œ† v : S.val, M ‚äó[A] adicCompletion K v.1) √ó
  (Œ† v : (Set.compl S.val), M ‚äó[A] adicCompletionIntegers K v.1)))

let q : ‚Ñ§ := 1
def LHS_limit : Type* :=
  lim (fun S : FiniteSubsets => (M ‚äó[A] ((Œ† v : S.val, adicCompletion K v.1) √ó
          (Œ† v : (Set.compl S.val), adicCompletionIntegers K v.1))))



end IsDedekindDomain
