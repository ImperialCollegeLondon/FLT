import FLT.Mathlib.Algebra.Algebra.Bilinear
import FLT.Mathlib.Algebra.Algebra.Pi
import FLT.Mathlib.Algebra.Module.Submodule.Basic
import FLT.Mathlib.NumberTheory.RamificationInertia.Basic
import FLT.Mathlib.Topology.Algebra.Module.Equiv
import FLT.Mathlib.Topology.Algebra.Module.ModuleTopology
import FLT.Mathlib.Topology.Algebra.UniformRing
import FLT.Mathlib.Topology.Algebra.Valued.ValuationTopology
import FLT.Mathlib.Topology.Algebra.Valued.WithVal
import FLT.Mathlib.RingTheory.TensorProduct.Basis
import FLT.Mathlib.RingTheory.Finiteness.Pi
import Mathlib.Algebra.Algebra.Subalgebra.Pi
import Mathlib.Algebra.BigOperators.Group.Finset.Basic
import Mathlib.Algebra.Group.Int.TypeTags
import Mathlib.Data.Int.WithZero
import Mathlib.RingTheory.DedekindDomain.FiniteAdeleRing
import Mathlib.Topology.Algebra.Algebra.Equiv
import Mathlib.Topology.Algebra.Module.ModuleTopology
import Mathlib.Topology.Algebra.Valued.NormedValued
import Mathlib.RingTheory.Valuation.RankOne
import Mathlib.Topology.Algebra.Module.FiniteDimension
import FLT.DedekindDomain.AdicValuation
import FLT.DedekindDomain.Completion.BaseChange
import FLT.Mathlib.Topology.Algebra.RestrictedProduct.Basic
import Mathlib.LinearAlgebra.TensorProduct.Prod
import Mathlib.Algebra.Colimit.Module
import Mathlib.RingTheory.Flat.Basic
import FLT.DedekindDomain.FiniteAdeleRing.TensorPi
import Mathlib.Order.DirectedInverseSystem




section IsDirectLimit

namespace Module

universe u

variable {R : Type*} [Semiring R] {Œπ : Type*} [Preorder Œπ] (M : Œπ ‚Üí Type*) (P : Type u)
variable [AddCommMonoid P] [Module R P]
variable [‚àÄ i, AddCommMonoid (M i)] [‚àÄ i, Module R (M i)] (f : ‚àÄ i j, i ‚â§ j ‚Üí M i ‚Üí‚Çó[R] M j)
variable (g : ‚àÄ i, M i ‚Üí‚Çó[R] P) (Hg : ‚àÄ i j hij x, g j (f i j hij x) = g i x)
variable [DecidableEq Œπ] [IsDirected Œπ (¬∑ ‚â§ ¬∑)] [Nonempty Œπ] [DirectedSystem M (f ¬∑ ¬∑ ¬∑)]

@[mk_iff] class IsDirectLimit : Prop where
  compatibility : ‚àÄ i j hij x, g j (f i j hij x) = g i x
  universal_property :
    ‚àÄ {X : Type u} [AddCommMonoid X] [Module R X],
    ‚àÄ gX : ‚àÄ i, M i ‚Üí‚Çó[R] X, ‚àÄ _ : ‚àÄ i j hij x, gX j (f i j hij x) = gX i x,
    ‚àÉ! œÜ : P ‚Üí‚Çó[R] X, ‚àÄ i x, œÜ (g i x) = gX i x

-- instance isDirectLimit :
--     IsDirectLimit M (Module.DirectLimit M f) f
--     (Module.DirectLimit.of R Œπ M f) where
--   compatibility i j hij x := Module.DirectLimit.of_f
--   universal_property gX HgX :=
--     ‚ü®Module.DirectLimit.lift R Œπ M f gX HgX,
--       by simp,
--       by
--         intro y hy
--         ext x
--         convert Module.DirectLimit.lift_unique y x with i
--         ext x'
--         simp only [LinearMap.coe_comp, Function.comp_apply]
--         exact (hy i x').symm‚ü©

section Iso

theorem universal_prop_identity [h : IsDirectLimit M P f g] :
  (h.universal_property g h.compatibility).exists.choose = LinearMap.id := by
  apply ExistsUnique.unique (h.universal_property g h.compatibility)
  ¬∑ exact (h.universal_property g h.compatibility).exists.choose_spec
  ¬∑ simp only [LinearMap.id_coe, id_eq, implies_true]

theorem IsDirectLimit.surj' [h : IsDirectLimit M P f g] : ‚àÄ m : P, ‚àÉ i, ‚àÉ mi : M i, g i mi = m := by
  intro m
  let Q : Submodule R P := Submodule.span R (‚ãÉ i, Set.range (g i))


  sorry

variable (P‚ÇÅ P‚ÇÇ : Type u) [AddCommMonoid P‚ÇÅ] [Module R P‚ÇÅ] [AddCommMonoid P‚ÇÇ] [Module R P‚ÇÇ]
variable (g‚ÇÅ : ‚àÄ i, M i ‚Üí‚Çó[R] P‚ÇÅ)
variable (g‚ÇÇ : ‚àÄ i, M i ‚Üí‚Çó[R] P‚ÇÇ)

set_option pp.proofs true in
noncomputable def iso_of_isDirectLimit
    [h‚ÇÅ : IsDirectLimit M P‚ÇÅ f g‚ÇÅ] [h‚ÇÇ : IsDirectLimit M P‚ÇÇ f g‚ÇÇ] :
    P‚ÇÅ ‚âÉ‚Çó[R] P‚ÇÇ where
  __ := (h‚ÇÅ.universal_property g‚ÇÇ h‚ÇÇ.compatibility).exists.choose
  invFun := (h‚ÇÇ.universal_property g‚ÇÅ h‚ÇÅ.compatibility).exists.choose
  left_inv := by
    simp only [AddHom.toFun_eq_coe, LinearMap.coe_toAddHom]
    refine Function.leftInverse_iff_comp.mpr ?_
    rw [‚Üê LinearMap.coe_comp, ‚Üê LinearMap.id_coe (R:=R)]
    refine DFunLike.coe_fn_eq.mpr
      (ExistsUnique.unique (h‚ÇÅ.universal_property g‚ÇÅ h‚ÇÅ.compatibility) ?_ ?_)
    ¬∑ intro i mi
      simp only [LinearMap.coe_comp, Function.comp_apply]
      rw [(ExistsUnique.exists (h‚ÇÅ.universal_property g‚ÇÇ h‚ÇÇ.compatibility)).choose_spec i mi,
        (ExistsUnique.exists (h‚ÇÇ.universal_property g‚ÇÅ h‚ÇÅ.compatibility)).choose_spec i mi]
    ¬∑ intro i mi
      simp only [LinearMap.id_coe, id_eq]
  right_inv := by
    simp only [AddHom.toFun_eq_coe, LinearMap.coe_toAddHom]
    refine Function.rightInverse_iff_comp.mpr ?_
    rw [‚Üê LinearMap.coe_comp, ‚Üê LinearMap.id_coe (R:=R)]
    refine DFunLike.coe_fn_eq.mpr
      (ExistsUnique.unique (h‚ÇÇ.universal_property g‚ÇÇ h‚ÇÇ.compatibility) ?_ ?_)
    ¬∑ intro i mi
      simp only [LinearMap.coe_comp, Function.comp_apply]
      rw [(ExistsUnique.exists (h‚ÇÇ.universal_property g‚ÇÅ h‚ÇÅ.compatibility)).choose_spec i mi,
        (ExistsUnique.exists (h‚ÇÅ.universal_property g‚ÇÇ h‚ÇÇ.compatibility)).choose_spec i mi]
    ¬∑ intro i mi
      simp only [LinearMap.id_coe, id_eq]

end Iso

end Module

end IsDirectLimit

section IsDirectLimit

namespace Module

variable {R : Type*} [Semiring R] {Œπ : Type*} [Preorder Œπ] (M : Œπ ‚Üí Type*) (P : Type*)
variable [AddCommMonoid P] [Module R P]
variable [‚àÄ i, AddCommMonoid (M i)] [‚àÄ i, Module R (M i)] (f : ‚àÄ i j, i ‚â§ j ‚Üí M i ‚Üí‚Çó[R] M j)
variable (g : ‚àÄ i, M i ‚Üí‚Çó[R] P)
variable [DecidableEq Œπ] [IsDirected Œπ (¬∑ ‚â§ ¬∑)] [Nonempty Œπ] [DirectedSystem M (f ¬∑ ¬∑ ¬∑)]

@[mk_iff] class IsDirectLimit' : Prop where
  surj : ‚àÄ m : P, ‚àÉ i, ‚àÉ mi : M i, g i mi = m
  inj :  ‚àÄ i j, ‚àÄ mi : M i, ‚àÄ mj : M j, g i mi = g j mj ‚Üí ‚àÉ (k : Œπ) (hik : i ‚â§ k) (hjk : j ‚â§ k),
      f i k hik mi = f j k hjk mj
  compatibility : ‚àÄ i j hij x, g j (f i j hij x) = g i x

variable [IsDirectLimit M P f g]


instance isDirectLimit' : IsDirectLimit' M (Module.DirectLimit M f) f
  (Module.DirectLimit.of R Œπ M f) where
  surj := Module.DirectLimit.exists_of
  inj i j mi mj h := by
    apply_fun Module.DirectLimit.linearEquiv _ _ at h
    simp_rw [Module.DirectLimit.linearEquiv_of] at h
    have ‚ü®k, hi, hj, hij‚ü© := Quotient.exact h
    exact ‚ü®k, hi, hj, hij‚ü©
  compatibility i j hij x := DirectLimit.of_f

variable (P‚ÇÅ P‚ÇÇ : Type*) [AddCommMonoid P‚ÇÅ] [Module R P‚ÇÅ] [AddCommMonoid P‚ÇÇ] [Module R P‚ÇÇ]
variable (g‚ÇÅ : ‚àÄ i, M i ‚Üí‚Çó[R] P‚ÇÅ)
variable (g‚ÇÇ : ‚àÄ i, M i ‚Üí‚Çó[R] P‚ÇÇ)


-- this is a nightmare. need to clean up and fully understand
set_option pp.proofs true in
open Classical in
noncomputable def lift [IsDirectLimit' M P‚ÇÅ f g‚ÇÅ] (Hg : ‚àÄ i j hij x, g‚ÇÇ j (f i j hij x) = g‚ÇÇ i x) :
  P‚ÇÅ ‚Üí‚Çó[R] P‚ÇÇ where
    toFun p :=
      g‚ÇÇ (choose (IsDirectLimit'.surj f p))
                   (choose (Classical.choose_spec (IsDirectLimit'.surj f (g:= g‚ÇÅ) p)))
    map_add' x y := by
      have hx := Classical.choose_spec (Classical.choose_spec (IsDirectLimit'.surj f (g:= g‚ÇÅ) x))
      have hy := Classical.choose_spec (Classical.choose_spec (IsDirectLimit'.surj f (g:= g‚ÇÅ) y))
      have hxy := Classical.choose_spec (Classical.choose_spec (IsDirectLimit'.surj f (g:= g‚ÇÅ) (x + y)))
      set ix := Classical.choose (IsDirectLimit'.surj f (g:= g‚ÇÅ) x)
      set mx := Classical.choose (Classical.choose_spec (IsDirectLimit'.surj f (g:= g‚ÇÅ) x))
      set iy := Classical.choose (IsDirectLimit'.surj f (g:= g‚ÇÅ) y)
      set my := Classical.choose (Classical.choose_spec (IsDirectLimit'.surj f (g:= g‚ÇÅ) y))
      set ixy := Classical.choose (IsDirectLimit'.surj f (g:= g‚ÇÅ) (x + y))
      set mxy := Classical.choose (Classical.choose_spec (IsDirectLimit'.surj f (g:= g‚ÇÅ) (x + y)))

      obtain ‚ü®k, hxk, hyk‚ü© := IsDirected.directed (r := (¬∑ ‚â§ ¬∑)) ix iy
      obtain ‚ü®k', hxyk', hkk'‚ü© := IsDirected.directed (r := (¬∑ ‚â§ ¬∑)) ixy k
      have sum_eq : g‚ÇÅ k' (f ix k' (le_trans hxk hkk') mx + f iy k' (le_trans hyk hkk') my) =
                    g‚ÇÅ ixy mxy := by
        rw [LinearMap.map_add]
        rw [IsDirectLimit'.compatibility ix k' (le_trans hxk hkk') mx]
        rw [IsDirectLimit'.compatibility iy k' (le_trans hyk hkk') my]
        rw [hx, hy, hxy]

      obtain ‚ü®k'', hk'k'', hxyk'', h'''‚ü© := IsDirectLimit'.inj (f:= f) k' ixy
                                        (f ix k' (le_trans hxk hkk') mx + f iy k' (le_trans hyk hkk') my)
                                        mxy sum_eq
      rw [‚Üê Hg ixy k'' hxyk'' mxy]
      have key_eq := congr_arg (g‚ÇÇ k'') h'''
      have g2_applied := congr_arg (g‚ÇÇ k'') h'''
      rw [ Hg k' k'' hk'k''] at g2_applied
      rw [LinearMap.map_add] at g2_applied
      rw [Hg ix k' (le_trans hxk hkk') mx, Hg iy k' (le_trans hyk hkk') my] at g2_applied
      rw [Hg ixy k'' hxyk'' mxy] at g2_applied
      rw [ Hg ixy k'' hxyk'' mxy]
      exact g2_applied.symm

    map_smul' r x := by
      have hx := Classical.choose_spec (Classical.choose_spec (IsDirectLimit'.surj f (g:= g‚ÇÅ) x))
      have hrx := Classical.choose_spec (Classical.choose_spec (IsDirectLimit'.surj f (g:= g‚ÇÅ) (r ‚Ä¢ x)))
      set ix := Classical.choose (IsDirectLimit'.surj f (g:= g‚ÇÅ) x)
      set mx := Classical.choose (Classical.choose_spec (IsDirectLimit'.surj f (g:= g‚ÇÅ) x))
      set irx := Classical.choose (IsDirectLimit'.surj f (g:= g‚ÇÅ) (r ‚Ä¢ x))
      set mrx := Classical.choose (Classical.choose_spec (IsDirectLimit'.surj f (g:= g‚ÇÅ) (r ‚Ä¢ x)))
      -- Step 1: Simplify RingHom.id R
      simp only [RingHom.id_apply]
      -- Goal becomes: (g‚ÇÇ irx) mrx = r ‚Ä¢ (g‚ÇÇ ix) mx

      -- Step 2: We have hrx : g‚ÇÅ irx mrx = r ‚Ä¢ x and hx : g‚ÇÅ ix mx = x
      -- So: g‚ÇÅ irx mrx = r ‚Ä¢ (g‚ÇÅ ix mx)
      -- By linearity of g‚ÇÅ ix: r ‚Ä¢ (g‚ÇÅ ix mx) = g‚ÇÅ ix (r ‚Ä¢ mx)

      -- We need to show: g‚ÇÅ irx mrx = g‚ÇÅ ix (r ‚Ä¢ mx)
      have smul_eq : g‚ÇÅ irx mrx = g‚ÇÅ ix (r ‚Ä¢ mx) := by
        rw [hrx, LinearMap.map_smul, hx]

      -- Step 3: By injectivity of the direct limit
      obtain ‚ü®k, hixk, hirxk, h_smul‚ü© := IsDirectLimit'.inj (f := f) ix irx (r ‚Ä¢ mx) mrx smul_eq.symm

      -- Step 4: Now we have: f ix k hixk (r ‚Ä¢ mx) = f irx k hirxk mrx
      -- Apply g‚ÇÇ k to both sides and use compatibility
      have g2_eq : (g‚ÇÇ k) (f ix k hixk (r ‚Ä¢ mx)) = (g‚ÇÇ k) (f irx k hirxk mrx) :=
        congr_arg (g‚ÇÇ k) h_smul

      -- Step 5: Use compatibility to simplify both sides
      rw [ Hg ix k hixk (r ‚Ä¢ mx), Hg irx k hirxk mrx] at g2_eq
      -- Now: (g‚ÇÇ ix) (r ‚Ä¢ mx) = (g‚ÇÇ irx) mrx

      -- Step 6: Use linearity of g‚ÇÇ ix
      rw [LinearMap.map_smul] at g2_eq
      -- Now: r ‚Ä¢ (g‚ÇÇ ix) mx = (g‚ÇÇ irx) mrx

      -- Step 7: This gives us exactly what we need!
      exact g2_eq.symm

set_option pp.proofs true in
@[simp] theorem lift_of [IsDirectLimit' M P‚ÇÅ f g‚ÇÅ] (Hg : ‚àÄ i j hij x, g‚ÇÇ j (f i j hij x) = g‚ÇÇ i x) {i} (x) :
  (lift M f P‚ÇÅ P‚ÇÇ g‚ÇÅ g‚ÇÇ Hg) (g‚ÇÅ i x) = g‚ÇÇ i x := by
  dsimp [lift]
  -- have := (Classical.choose_spec (IsDirectLimit'.surj f (g:= g‚ÇÅ) (g‚ÇÅ i x))).choose_spec
  have h_spec := Classical.choose_spec
    (Classical.choose_spec (IsDirectLimit'.surj f (g := g‚ÇÅ) (g‚ÇÅ i x)))
-- h_spec : g‚ÇÅ (Classical.choose (IsDirectLimit'.surj (g‚ÇÅ i x)))
--              (Classical.choose (lift._proof_1 M f P‚ÇÅ g‚ÇÅ ((g‚ÇÅ i) x))) = g‚ÇÅ i x

-- Now you have two equal elements in P‚ÇÅ: both equal g‚ÇÅ i x
-- By injectivity of the direct limit:
  have ‚ü®k, hik, hjk, h_eq‚ü© := IsDirectLimit'.inj (f:=f) i
    (Classical.choose (IsDirectLimit'.surj f (g := g‚ÇÅ) (g‚ÇÅ i x)))
    x (Classical.choose (lift._proof_1 M f P‚ÇÅ g‚ÇÅ ((g‚ÇÅ i) x))) (h_spec.symm)
-- h_eq : f i k hik x = f (Classical.choose (IsDirectLimit'.surj (g‚ÇÅ i x))) k hjk
--                      (Classical.choose (lift._proof_1 M f P‚ÇÅ g‚ÇÅ ((g‚ÇÅ i) x)))

-- Now use compatibility (your hypothesis Hg):
  rw [‚Üê Hg i k hik x]
  rw [‚Üê Hg (Classical.choose (IsDirectLimit'.surj f (g := g‚ÇÅ) (g‚ÇÅ i x))) k hjk
         (Classical.choose (lift._proof_1 M f P‚ÇÅ g‚ÇÅ ((g‚ÇÅ i) x)))]
  rw [h_eq]


theorem lift_unique [IsDirectLimit' M P‚ÇÅ f g‚ÇÅ]
  (F : P‚ÇÅ ‚Üí‚Çó[R] P‚ÇÇ) (x) : F x = (lift M f P‚ÇÅ P‚ÇÇ g‚ÇÅ (fun i ‚Ü¶ F.comp <| g‚ÇÅ i)
  (fun i j hij x ‚Ü¶ by
    simp only [LinearMap.coe_comp, Function.comp_apply]
    exact LinearMap.congr_arg (IsDirectLimit'.compatibility i j hij x))) x := by
    dsimp [lift]
    rw [Classical.choose_spec (Classical.choose_spec (IsDirectLimit'.surj f (g:= g‚ÇÅ) x))]

noncomputable def iso_of_isDirectLimit'
    [h‚ÇÅ : IsDirectLimit' M P‚ÇÅ f g‚ÇÅ] [h‚ÇÇ : IsDirectLimit' M P‚ÇÇ f g‚ÇÇ] :
    P‚ÇÅ ‚âÉ‚Çó[R] P‚ÇÇ where
  __ := (lift M f P‚ÇÅ P‚ÇÇ g‚ÇÅ g‚ÇÇ h‚ÇÇ.compatibility)
  invFun := (lift M f P‚ÇÇ P‚ÇÅ g‚ÇÇ g‚ÇÅ h‚ÇÅ.compatibility)
  left_inv x := by
    simp only [AddHom.toFun_eq_coe, LinearMap.coe_toAddHom]
    obtain ‚ü®i, mi, hmi‚ü© := h‚ÇÅ.surj x
    rw [‚Üê hmi]
    simp only [lift_of]
  right_inv x := by
    simp only [AddHom.toFun_eq_coe, LinearMap.coe_toAddHom]
    obtain ‚ü®i, mi, hmi‚ü© := h‚ÇÇ.surj x
    rw [‚Üê hmi]
    simp only [lift_of]


end Module

end IsDirectLimit

section TensorProduct

open scoped TensorProduct
open Module

variable {R : Type*} [CommSemiring R] {Œπ : Type*} [Preorder Œπ] (M : Œπ ‚Üí Type*) (P : Type*)
variable [AddCommMonoid P] [Module R P]
variable [‚àÄ i, AddCommMonoid (M i)] [‚àÄ i, Module R (M i)] (f : ‚àÄ i j, i ‚â§ j ‚Üí M i ‚Üí‚Çó[R] M j)
variable (g : ‚àÄ i, M i ‚Üí‚Çó[R] P)
variable [DecidableEq Œπ] [IsDirected Œπ (¬∑ ‚â§ ¬∑)] [Nonempty Œπ] [DirectedSystem M (f ¬∑ ¬∑ ¬∑)]
variable (N : Type*) [AddCommMonoid N] [Module R N] [h : IsDirectLimit' M P f g]

def incTensorMap (i j : Œπ) (h : i ‚â§ j) : M i ‚äó[R] N ‚Üí‚Çó[R] M j ‚äó[R] N :=
   LinearMap.rTensor N (f i j h)

def tensorMap (i : Œπ) : M i ‚äó[R] N ‚Üí‚Çó[R] P ‚äó[R] N :=
  LinearMap.rTensor N (g i)

instance : DirectedSystem (fun i ‚Ü¶ M i ‚äó[R] N) fun x1 x2 x3 ‚Ü¶ ‚áë(incTensorMap M f N x1 x2 x3) :=
  sorry

lemma comp (i k) (hik : i ‚â§ k) :
  (tensorMap M P g N k).comp (incTensorMap M f N i k hik)
    = tensorMap M P g N i := by
    dsimp [tensorMap, incTensorMap]
    ext u v
    simp [h.compatibility i k hik u]


theorem universal_property_inj {X : Type*} [AddCommMonoid X] [Module R X]
  (gX : ‚àÄ i, M i ‚Üí‚Çó[R] X) (HgX : ‚àÄ i j hij x, gX j (f i j hij x) = gX i x)
  (unique : ‚àÉ! œÜ : X ‚Üí‚Çó[R] P, ‚àÄ i x, œÜ (gX i x) = g i x) {i j mi mj} (hij : i‚â§j)
  (hmij : gX i mi = gX j (mj)) :
    ‚àÉ k, ‚àÉ (hik : i ‚â§ k) (hjk : j ‚â§ k), (f i k hik) mi = (f j k hjk) mj := by
    obtain ‚ü®œÜ, hœÜ, unique‚ü© := unique
    have hœÜi := hœÜ i mi
    have hœÜj := hœÜ j mj
    rw [hmij] at hœÜi
    rw [hœÜi] at hœÜj
    obtain ‚ü®k, hik, hjk, fijk‚ü© := h.inj i j mi mj hœÜj
    exact ‚ü®k, hik, hjk, fijk‚ü©


theorem universal_property {X : Type*} [AddCommMonoid X] [Module R X]
  (gX : ‚àÄ i, M i ‚Üí‚Çó[R] X) (HgX : ‚àÄ i j hij x, gX j (f i j hij x) = gX i x)
  (unique : ‚àÉ! œÜ : X ‚Üí‚Çó[R] P, ‚àÄ i x, œÜ (gX i x) = g i x) :
  IsDirectLimit' M X f gX where
  surj m := by

    sorry
  inj i j mi mj hmij := by
    obtain ‚ü®œÜ, hœÜ, unique‚ü© := unique
    have hœÜi := hœÜ i mi
    have hœÜj := hœÜ j mj
    rw [hmij] at hœÜi
    rw [hœÜi] at hœÜj
    obtain ‚ü®k, hik, hjk, fijk‚ü© := h.inj i j mi mj hœÜj
    exact ‚ü®k, hik, hjk, fijk‚ü©

  compatibility := by

    sorry


instance : IsDirectLimit' (fun i ‚Ü¶ (M i ‚äó[R] N)) (P ‚äó[R] N) (incTensorMap M f N)
  (tensorMap M P g N) where
    surj m := by
      induction m --using TensorProduct.induction_on
      case zero =>
        obtain ‚ü®i, mi, hmi‚ü© := h.surj (0 : P)
        exact ‚ü®i, mi ‚äó‚Çú[R] 0, by simp [tensorMap]‚ü©
      case tmul x y =>
        obtain ‚ü®i, mi, hmi‚ü© := h.surj x
        exact ‚ü®i, mi ‚äó‚Çú[R] y, by dsimp [tensorMap]; rw [hmi]‚ü©
      case add x y hx hy =>
        obtain ‚ü®i, mi, hmi‚ü© := hx
        obtain ‚ü®j, mj, hmj‚ü© := hy
        have ‚ü®k, hik, hjk‚ü© := IsDirected.directed (r := (¬∑ ‚â§ ¬∑)) i j
        let mik := (incTensorMap M f N i k hik) mi
        let mjk := (incTensorMap M f N j k hjk) mj
        use k, mik + mjk
        simp only [mik, mjk, LinearMap.map_add]
        rw [‚Üê LinearMap.comp_apply, ‚Üê LinearMap.comp_apply, comp, comp, hmi, hmj]
    inj i j mi mj hmij := by
      sorry
    compatibility := sorry

instance : DirectedSystem (fun i ‚Ü¶ M i ‚äó[R] N) fun x1 x2 x3 ‚Ü¶ ‚áë(incTensorMap M f N x1 x2 x3) :=
  sorry

#check (Module.iso_of_isDirectLimit' (fun i ‚Ü¶ (M i ‚äó[R] N)) (incTensorMap M f N)
 (Module.DirectLimit (fun i ‚Ü¶ (M i ‚äó[R] N)) (incTensorMap M f N)) (P ‚äó[R] N)
 (Module.DirectLimit.of R Œπ (fun i ‚Ü¶ (M i ‚äó[R] N)) (incTensorMap M f N)) (tensorMap M P g N))

include g in
noncomputable def iso' :
  (Module.DirectLimit (fun i ‚Ü¶ (M i ‚äó[R] N)) (incTensorMap M f N)) ‚âÉ‚Çó[R] (P ‚äó[R] N) := by
  haveI : DirectedSystem (fun i ‚Ü¶ M i ‚äó[R] N) fun x1 x2 x3 ‚Ü¶ ‚áë(incTensorMap M f N x1 x2 x3) := sorry
  apply (Module.iso_of_isDirectLimit' (fun i ‚Ü¶ (M i ‚äó[R] N)) (incTensorMap M f N)
    (Module.DirectLimit (fun i ‚Ü¶ (M i ‚äó[R] N)) (incTensorMap M f N)) (P ‚äó[R] N)
    (Module.DirectLimit.of R Œπ (fun i ‚Ü¶ (M i ‚äó[R] N)) (incTensorMap M f N)) (tensorMap M P g N))




end TensorProduct



section RestrictedProduct



open Set Filter

variable {Œπ : Type*} {ùìï : Filter Œπ}

variable (ùìï) in
/-- The complements of sets in a `Filter`.
E.g. for the cofinite filter, these are just the finite subsets. -/
def Filter.complement : Set (Set Œπ) := (fun S => S·∂ú) '' ùìï.sets

theorem principal_filter_order {S‚ÇÅ S‚ÇÇ : ùìï.complement} (h : S‚ÇÅ ‚â§ S‚ÇÇ) :
    (ùìü S‚ÇÇ·∂ú : Filter Œπ) ‚â§ ùìü S‚ÇÅ·∂ú := by
  simp only [le_principal_iff, mem_principal, compl_subset_compl]; exact h

theorem filter_bot :
    ‚àÄ S : ùìï.complement, ùìï ‚â§ (ùìü S·∂ú : Filter Œπ) := by
  intro S
  simp only [le_principal_iff]
  refine Filter.mem_sets.mp ?_
  have h : ùìï.sets = (fun S => S·∂ú) '' (ùìï.complement) := by
    rw[complement]
    exact Eq.symm (compl_compl_image ùìï.sets)
  rw[h]
  simp

open scoped RestrictedProduct

variable {R : Œπ ‚Üí Type*} {A : (i : Œπ) ‚Üí Set (R i)}

variable (A) in
/-- This is (isomorphic to) `(Œ† i ‚àà S, R i) √ó (Œ† i ‚àâ S, A i)` -/
def mem_A_away_from_S (S : ùìï.complement) : Type _ :=
  Œ† ≥ i, [R i, A i]_[ùìü S·∂ú]

/-- The inclusions between `mem_A_away_from_S` which will form the directed system. -/
def inclusion (S‚ÇÅ S‚ÇÇ : ùìï.complement) (h : S‚ÇÅ ‚â§ S‚ÇÇ) :
    mem_A_away_from_S A S‚ÇÅ ‚Üí mem_A_away_from_S A S‚ÇÇ :=
  RestrictedProduct.inclusion _ _ (principal_filter_order h)

instance directed_system :
    @DirectedSystem (ùìï.complement) _ (mem_A_away_from_S A) (inclusion) where
  map_self _ _ := rfl
  map_map _ _ _ _ _ _ := rfl

/-- The maps from the directed system to the actual restricted product. -/
def inclusion_to_restrictedProduct (S : ùìï.complement) :
    mem_A_away_from_S A S ‚Üí Œ† ≥ i, [R i, A i]_[ùìï] :=
  RestrictedProduct.inclusion _ _ (filter_bot S)

-- ....


def inclusion' (S‚ÇÅ S‚ÇÇ : ùìï.complement) (h : S‚ÇÅ ‚â§ S‚ÇÇ) :
    Œ† ≥ i, [R i, A i]_[ùìü S‚ÇÅ·∂ú] ‚Üí Œ† ≥ i, [R i, A i]_[ùìü S‚ÇÇ·∂ú] :=
  RestrictedProduct.inclusion _ _ (principal_filter_order h)

instance directed_system' :
    @DirectedSystem (ùìï.complement) _ (mem_A_away_from_S A) (inclusion') where
  map_self _ _ := rfl
  map_map _ _ _ _ _ _ := rfl

/-- The maps from the directed system to the actual restricted product. -/
def inclusion_to_restrictedProduct' (S : ùìï.complement) :
    Œ† ≥ i, [R i, A i]_[ùìü S·∂ú] ‚Üí Œ† ≥ i, [R i, A i]_[ùìï] :=
  RestrictedProduct.inclusion _ _ (filter_bot S)


end RestrictedProduct



variable {Œπ : Type*} {R : Œπ ‚Üí Type*} {‚Ñ± : Filter Œπ}

variable {T : Œπ ‚Üí Type*} -- subobject type
variable [Œ† i, SetLike (T i) (R i)]
variable {B : Œ† i, T i}

open scoped RestrictedProduct TensorProduct Module.IsDirectLimit

variable {A : Type*} [CommRing A]

-- In open PR #25715
-- restricted product of addcommgroups is an addcommgroup
instance [Œ† i, AddCommGroup (R i)] [‚àÄ i, AddSubgroupClass (T i) (R i)] :
    AddCommGroup (Œ† ≥ i, [R i, B i]_[‚Ñ±]) where
  __ := inferInstanceAs (AddGroup (Œ† ≥ i, [R i, B i]_[‚Ñ±]))
  add_comm a b := by ext i; simp [add_comm]

-- when #25715 lands we'll be able to change these to AddCommMonoid
-- restricted product of A-modules is an A-module
instance module [Œ† i, AddCommGroup (R i)] [‚àÄ i, Module A (R i)]
    -- next line is how we do "SubmoduleClass"
    [‚àÄ i, AddSubgroupClass (T i) (R i)] [‚àÄ i, SMulMemClass (T i) A (R i)] :
    Module A (Œ† ≥ i, [R i, B i]_[‚Ñ±]) where
      smul a x := ‚ü®fun i ‚Ü¶ a ‚Ä¢ x i, Filter.Eventually.mono x.property (fun _ hi ‚Ü¶
     SMulMemClass.smul_mem a hi)‚ü©
      one_smul b := by ext; simp
      mul_smul x y b := by ext; simp [mul_smul]
      smul_zero b := by ext; simp
      smul_add x a b := by ext; simp
      add_smul a b x := by
        ext
        simp only [RestrictedProduct.smul_apply, RestrictedProduct.add_apply, add_smul]
      zero_smul b := by ext; simp

noncomputable def Submodule.lTensor (M : Type*) {N : Type*} [AddCommGroup M] [Module A M]
    [AddCommGroup N] [Module A N] (P : Submodule A N) : Submodule A (M ‚äó[A] N) :=
  LinearMap.range (P.subtype.lTensor M)


variable {Œπ : Type*} {R : Œπ ‚Üí Type*} {‚Ñ± : Filter Œπ} [Preorder Œπ]

variable {T : Œπ ‚Üí Type*} -- subobject type
variable [Œ† i, SetLike (T i) (R i)]
variable {B : Œ† i, T i}
variable {A : Type*} [CommRing A]

variable [Œ† i, AddCommGroup (R i)] [‚àÄ i, Module A (R i)] {C : ‚àÄ i, Submodule A (R i)}
{M : Type*} [AddCommGroup M] [Module A M] [Module.FinitePresentation A M] (S : Filter.complement ‚Ñ±)

open Set Filter RestrictedProduct

instance add (S : ‚Ñ±.complement) :
  AddCommMonoid (mem_A_away_from_S (fun i ‚Ü¶ (C i : Set (R i))) S) := by
  dsimp [mem_A_away_from_S]
  exact AddCommGroup.toDivisionAddCommMonoid.toAddCommMonoid

instance module' (S : ‚Ñ±.complement) :
  Module A (mem_A_away_from_S (fun i ‚Ü¶ (C i : Set (R i))) S) := by
  dsimp [mem_A_away_from_S]
  exact module


def inclusion_module (S‚ÇÅ S‚ÇÇ : ‚Ñ±.complement) (h : S‚ÇÅ ‚â§ S‚ÇÇ) :
    mem_A_away_from_S (fun i ‚Ü¶ (C i : Set (R i))) S‚ÇÅ ‚Üí‚Çó[A]
      mem_A_away_from_S ((fun i ‚Ü¶ (C i : Set (R i)))) S‚ÇÇ where
  toFun := inclusion S‚ÇÅ S‚ÇÇ h
  map_add' _ _ := rfl
  map_smul' _ _ := rfl

def inclusion_module' (S‚ÇÅ S‚ÇÇ : ‚Ñ±.complement) (h : S‚ÇÅ ‚â§ S‚ÇÇ) :
    Œ† ≥ i, [R i, C i]_[ùìü S‚ÇÅ·∂ú]  ‚Üí‚Çó[A]
      Œ† ≥ i, [R i, C i]_[ùìü S‚ÇÇ·∂ú]  where
  toFun := inclusion' S‚ÇÅ S‚ÇÇ h
  map_add' _ _ := rfl
  map_smul' _ _ := rfl


def inclusion_to_restricted_product_module (S : ‚Ñ±.complement) :
  mem_A_away_from_S (fun i ‚Ü¶ (C i : Set (R i))) S ‚Üí‚Çó[A] Œ† ≥ i, [R i, C i]_[‚Ñ±] where
  toFun := inclusion_to_restrictedProduct S
  map_add' _ _ := rfl
  map_smul' _ _ := rfl

def inclusion_to_restricted_product_module' (S : ‚Ñ±.complement) :
  Œ† ≥ i, [R i, C i]_[ùìü S·∂ú] ‚Üí‚Çó[A] Œ† ≥ i, [R i, C i]_[‚Ñ±] where
  toFun := inclusion_to_restrictedProduct S
  map_add' _ _ := rfl
  map_smul' _ _ := rfl

instance directed : IsDirected (‚Ñ±.complement) (¬∑ ‚â§ ¬∑) := by
  refine { directed := ?_ }
  intro Si Sj
  obtain ‚ü®Si, hi‚ü© := Si
  obtain ‚ü®Sj, hj‚ü© := Sj
  let c := Si ‚à™ Sj
  have : c ‚àà ‚Ñ±.complement := by
    unfold Filter.complement at hi hj ‚ä¢
    simp only [mem_image, Filter.mem_sets] at hi hj ‚ä¢
    obtain ‚ü®si, hsi‚ü© := hi
    obtain ‚ü®sj, hsj‚ü© := hj
    use si ‚à© sj
    constructor
    ¬∑ exact ‚Ñ±.inter_sets hsi.1 hsj.1
    ¬∑ unfold c
      rw [compl_inter, hsi.2, hsj.2]
  use ‚ü®c, this‚ü©
  constructor <;>
  simp [c]

open Set
instance RestrictedProductIsDirectLimit :
  Module.IsDirectLimit' (mem_A_away_from_S  (fun i ‚Ü¶ (C i : Set (R i))))
  Œ† ≥ i, [R i, C i]_[‚Ñ±] (inclusion_module (‚Ñ± := ‚Ñ±))
  (inclusion_to_restricted_product_module ) where
  inj S·µ¢ S‚±º mi mj hmij := by
    obtain ‚ü®S‚Çñ, hik, hjk‚ü© := @directed_of _ (¬∑ ‚â§ ¬∑) directed S·µ¢ S‚±º
    refine ‚ü®S‚Çñ, hik, hjk, ?_‚ü©
    dsimp [inclusion_module,_root_.inclusion, RestrictedProduct.inclusion]
    dsimp [inclusion_to_restricted_product_module, inclusion_to_restrictedProduct,
      RestrictedProduct.inclusion] at hmij
    apply Subtype.ext
    simp only
    injection hmij
  surj r := by
    dsimp [inclusion_to_restricted_product_module, inclusion_to_restrictedProduct]
    have : ‚àÖ ‚àà ‚Ñ±.complement := by
      rw [complement]
      simp only [mem_image, Filter.mem_sets, compl_empty_iff, exists_eq_right, univ_mem]
    let b:= r.property
    let c:= r.1
    have : { i : Œπ | r.1 i ‚àà (C i : Set (R i)) }·∂ú ‚àà ‚Ñ±.complement := by
      rw [complement]
      simp only [mem_image, Filter.mem_sets]
      refine ‚ü®{ i : Œπ | r.1 i ‚àà (C i : Set (R i)) }, r.property, ?_‚ü©
      rfl
    use ‚ü®{ i : Œπ | r.1 i ‚àà (C i : Set (R i)) }·∂ú, this‚ü©
    apply RestrictedProduct.exists_inclusion_eq_of_eventually
    simp only [SetLike.mem_coe, compl_compl, eventually_principal, mem_setOf_eq]
    exact fun x a ‚Ü¶ a
  compatibility i j hij x := by
    dsimp [inclusion_to_restricted_product_module, inclusion_to_restrictedProduct,
    inclusion_module,_root_.inclusion, inclusion_module,RestrictedProduct.inclusion]
    exact Subtype.ext rfl


#check TensorProduct.directLimitRight


variable {Œπ : Type*} (R : Œπ ‚Üí Type*) (S : Set Œπ) [‚àÄ i, Decidable (i ‚àà S)]

open scoped Filter

namespace RestrictedProduct

section type

variable (A : (i : Œπ) ‚Üí Set (R i))

def principalEquivProd : Œ† ≥ i, [R i, A i]_[ùìü S] ‚âÉ
    (Œ† i : {i // i ‚àà S}, A i) √ó (Œ† i : {i // i ‚àâ S}, R i) where
  toFun x := (fun i ‚Ü¶ ‚ü®x i, x.property i.property‚ü©, fun i ‚Ü¶ x i)
  invFun y := ‚ü®fun i ‚Ü¶ if hi : i ‚àà S then y.1 ‚ü®i, hi‚ü© else y.2 ‚ü®i, hi‚ü©,
  Filter.eventually_principal.mpr (fun i hi ‚Ü¶ by simp only [hi]; exact (y.1 ‚ü®i, hi‚ü©).2)‚ü©
  left_inv x := by
    simp only [dite_eq_ite, ite_self]
    rfl
  right_inv x := by
    simp only [mk_apply, Subtype.coe_prop, ‚ÜìreduceDIte, Subtype.coe_eta]
    ext i
    ¬∑ rfl
    ¬∑ simp only [dif_neg i.property]

def principalEquivProd' : Œ† ≥ i, [R i, A i]_[ùìü S·∂ú] ‚âÉ
    (Œ† i : {i // i ‚àâ S}, A i) √ó (Œ† i : {i // i ‚àà S}, R i) where
  toFun x := (fun i ‚Ü¶ ‚ü®x i, x.property i.property‚ü©, fun i ‚Ü¶ x i)
  invFun y := ‚ü®fun i ‚Ü¶ if hi : i ‚àâ S then y.1 ‚ü®i, hi‚ü© else y.2 ‚ü®i, by simpa using hi‚ü©,
  Filter.eventually_principal.mpr (fun i hi ‚Ü¶ by
    simp only [mem_compl_iff] at hi
    simp only [hi]
    exact (y.1 ‚ü®i, hi‚ü©).2)‚ü©
  left_inv x := by
    simp only [dite_eq_ite, ite_self]
    rfl
  right_inv x := by
    simp only [dite_not, mk_apply, Subtype.coe_prop, ‚ÜìreduceDIte]
    ext i <;> simp only [i.property, ‚ÜìreduceDIte]



end type


variable {T : Œπ ‚Üí Type*} -- subobject type
variable [Œ† i, SetLike (T i) (R i)]
variable {A : Œ† i, T i}

section monoid

@[to_additive]
def principalMulEquivProd [Œ† i, Monoid (R i)] [‚àÄ i, SubmonoidClass (T i) (R i)] :
    Œ† ≥ i, [R i, A i]_[ùìü S] ‚âÉ* (Œ† i : {i // i ‚àà S}, A i) √ó (Œ† i : {i // i ‚àâ S}, R i) where
  __ := principalEquivProd R S _
  map_mul' _ _ := rfl

end monoid


end RestrictedProduct

section
variable {Œπ : Type*}
variable {R : Œπ ‚Üí Type*}
variable {‚Ñ± : Filter Œπ}

variable {T : Œπ ‚Üí Type*} -- subobject type
variable [Œ† i, SetLike (T i) (R i)]
--variable {B : Œ† i, T i}

open scoped RestrictedProduct TensorProduct

variable {A : Type*} [CommRing A]



open Filter


noncomputable def RestrictedProduct.principal [Œ† i, AddCommGroup (R i)]
    [‚àÄ i, Module A (R i)] {C : ‚àÄ i, Submodule A (R i)}
    (S : Set Œπ) [‚àÄ i, Decidable (i ‚àà S)] :
   (Œ† ≥ i, [R i, C i]_[ùìü S]) ‚âÉ‚Çó[A] ((Œ† i : {i // i ‚àà S}, C i) √ó
  (Œ† i : {i // i ‚àâ S}, R i)) where
    __ := principalAddEquivSum R S (A := C)
    map_smul' m x := by
      simp only [AddEquiv.toEquiv_eq_coe, Equiv.toFun_as_coe, EquivLike.coe_coe, RingHom.id_apply]
      dsimp [principalAddEquivSum, principalEquivProd]
      ext i
      ¬∑ simp only [Pi.smul_apply, SetLike.coe_sort_coe, SetLike.val_smul]
      ¬∑ simp only [Pi.smul_apply]

noncomputable def RestrictedProduct.princpal' [Œ† i, AddCommGroup (R i)]
    [‚àÄ i, Module A (R i)] {C : ‚àÄ i, Submodule A (R i)}
    (S : Set Œπ) [‚àÄ i, Decidable (i ‚àà S)] : Œ† ≥ i, [R i, C i]_[ùìü S·∂ú] ‚âÉ
    (Œ† i : {i // i ‚àâ S}, C i) √ó (Œ† i : {i // i ‚àà S}, R i) := sorry


noncomputable def RestrictedProduct.principal_tensor_comm' [Œ† i, AddCommGroup (R i)]
    [‚àÄ i, Module A (R i)] {C : Œ† i, Submodule A (R i)} {M : Type*} [AddCommGroup M] [Module A M]
    [Module.FinitePresentation A M] {S : Set Œπ} :
   M ‚äó[A] (Œ† ≥ i, [R i, C i]_[ùìü S]) ‚âÉ‚Çó[A] (Œ† ≥ i, [M ‚äó[A] R i, (C i).lTensor M]_[ùìü S]) := sorry

variable [Œ† i, AddCommGroup (R i)] [‚àÄ i, Module A (R i)] {C : ‚àÄ i, Submodule A (R i)}
instance : DecidableEq ‚Ñ±.complement := sorry
instance : Nonempty ‚Ñ±.complement := sorry
instance : DirectedSystem (mem_A_away_from_S fun i ‚Ü¶ (C i : Set (R i)))
      fun x1 x2 x3 ‚Ü¶ ‚áë(inclusion_module (‚Ñ± := ‚Ñ±) (C:= C) x1 x2 x3) := directed_system

#check Module.DirectLimit (mem_A_away_from_S fun i ‚Ü¶ (C i : Set (R i)))
  (f := inclusion_module (C:=C) (‚Ñ± := ‚Ñ±))


#check Module.iso_of_isDirectLimit' (mem_A_away_from_S  (fun i ‚Ü¶ (C i : Set (R i))))
       (inclusion_module (‚Ñ± := ‚Ñ±)) (Œ† ≥ i, [R i, C i]_[‚Ñ±])
       (Module.DirectLimit (mem_A_away_from_S fun i ‚Ü¶ (C i : Set (R i)))
       (inclusion_module (‚Ñ± := ‚Ñ±)) )


-- this now compiles
noncomputable def RestrictedProduct.tensor_comm' [Œ† i, AddCommGroup (R i)]
    [‚àÄ i, Module A (R i)] {C : ‚àÄ i, Submodule A (R i)} [Preorder Œπ]
    {M : Type*} [AddCommGroup M] [Module A M] [Module.FinitePresentation A M] [Module.Flat A M] :
    M ‚äó[A] (Œ† ≥ i, [R i, C i]_[‚Ñ±]) ‚âÉ‚Çó[A] Œ† ≥ i, [M ‚äó[A] R i, (C i).lTensor M]_[‚Ñ±] := by
    haveI : Nonempty ‚Ñ±.complement := sorry
    haveI :  DirectedSystem (mem_A_away_from_S (fun i ‚Ü¶ ((C i).lTensor M : Set (M ‚äó[A] R i))))
      fun x1 x2 x3 ‚Ü¶ ‚áë(inclusion_module (‚Ñ± := ‚Ñ±)  x1 x2 x3) := directed_system
    let comp1 := TensorProduct.directLimitRight (inclusion_module (C:=C) (‚Ñ± := ‚Ñ±)) M (R:=A)
    let comp := Module.iso_of_isDirectLimit' (mem_A_away_from_S  (fun i ‚Ü¶ (C i : Set (R i))))
       (inclusion_module (‚Ñ± := ‚Ñ±)) (Œ† ≥ i, [R i, C i]_[‚Ñ±])
       (Module.DirectLimit (mem_A_away_from_S fun i ‚Ü¶ (C i : Set (R i))) (inclusion_module (C:=C) (‚Ñ± := ‚Ñ±)))
      (inclusion_to_restricted_product_module) (Module.DirectLimit.of A _
      (mem_A_away_from_S fun i ‚Ü¶ (C i : Set (R i))) (inclusion_module (‚Ñ± := ‚Ñ±)))
    let comp2 := Module.iso_of_isDirectLimit' (mem_A_away_from_S
      (fun i ‚Ü¶ ((C i).lTensor M : Set (M ‚äó[A] R i))))
       (inclusion_module (‚Ñ± := ‚Ñ±)) Œ† ≥ i, [M ‚äó[A] R i, (C i).lTensor M]_[‚Ñ±]
       (Module.DirectLimit (mem_A_away_from_S
      (fun i ‚Ü¶ ((C i).lTensor M : Set (M ‚äó[A] R i)))) (inclusion_module (‚Ñ± := ‚Ñ±)))
      (inclusion_to_restricted_product_module) (Module.DirectLimit.of A _
    (mem_A_away_from_S
      (fun i ‚Ü¶ ((C i).lTensor M : Set (M ‚äó[A] R i)))) (inclusion_module (‚Ñ± := ‚Ñ±)))
    -- haveI (i : Œπ) : Submodule A (M ‚äó[A] C i) := Module.jacobson A (M ‚äó[A] ‚Ü•(C i))
    let comp3 : M ‚äó[A] (Œ† ≥ i, [R i, C i]_[‚Ñ±]) ‚âÉ‚Çó[A]
      M ‚äó[A] Module.DirectLimit (mem_A_away_from_S fun i ‚Ü¶ (C i : Set (R i))) inclusion_module :=
      LinearEquiv.lTensor M comp
    let comp4 :=  comp3 ‚â™‚â´‚Çó comp1
   -- let comp5 := comp4 ‚â™‚â´‚Çó comp2.symm
    let comp5 (S : Set Œπ) : M ‚äó[A] ((Œ† i : {i // i ‚àà S}, R i) √ó (Œ† i : {i // i ‚àâ S}, C i)) ‚âÉ‚Çó[A]
      (M ‚äó[A] Œ† i : {i // i ‚àà S}, R i) √ó (M ‚äó[A] Œ† i : {i // i ‚àâ S}, C i)  :=
        TensorProduct.prodRight A A M ((i : { i // i ‚àà S }) ‚Üí R ‚Üëi) ((i : { i // i ‚àâ S }) ‚Üí ‚Ü•(C ‚Üëi))
    have (i : Œπ):= (M ‚äó[A] C i)
    unfold mem_A_away_from_S at comp
    simp at comp
    let comp6 : Module.DirectLimit (fun (S: ‚Ñ±.complement) ‚Ü¶ Œ† ≥ i, [R i, C i]_[ùìü S·∂ú]) inclusion_module'
     ‚âÉ‚Çó[A] Module.DirectLimit (fun (S:‚Ñ±.complement) ‚Ü¶ ((Œ† i : {i // i ‚àâ (S : Set Œπ)}, C i.1) √ó
  (Œ† i : {i // i ‚àà (S : Set Œπ) }, R i.1))) (inclusion_module')  := RestrictedProduct.principal'


  #exit

  LinearEquiv.ofBijective (TensorProduct.lift {
    toFun m := {
      toFun x := ‚ü®fun i ‚Ü¶ m ‚äó‚Çú (x i), Filter.Eventually.mono x.property (fun i hi ‚Ü¶
     LinearMap.mem_range.mpr ‚ü®m ‚äó‚Çú[A] ‚ü®x i, hi‚ü©, rfl‚ü©)‚ü©
      map_add' x y := by
        ext i
        simp only [add_apply, mk_apply, TensorProduct.tmul_add]
      map_smul' a x := by
        ext i
        simp only [smul_apply, TensorProduct.tmul_smul, mk_apply, RingHom.id_apply]
    }
    map_add' x y := by
      refine LinearMap.ext (fun x‚ÇÅ ‚Ü¶ ?_)
      ext i
      simp only [LinearMap.coe_mk, AddHom.coe_mk, mk_apply, LinearMap.add_apply, add_apply,
        TensorProduct.add_tmul]
    map_smul' a x := by
      refine LinearMap.ext (fun x‚ÇÅ ‚Ü¶ ?_)
      ext i
      simp only [LinearMap.coe_mk, AddHom.coe_mk, mk_apply, RingHom.id_apply, LinearMap.smul_apply,
        smul_apply, TensorProduct.smul_tmul']
  }) ‚ü®
  fun a b h ‚Ü¶ by
    -- injectivity proof: if `a`, `b` in `M ‚äó[A] Œ† ≥ (i : Œπ), [R i, ‚Üë(C i)]_[‚Ñ±]`
    -- and their images in `Œ† ≥ (i : Œπ), [M ‚äó[A] R i, ‚Üë(Submodule.lTensor M (C i))]_[‚Ñ±]`
    -- are the same, then choose some `S ‚àà ‚Ñ±` such that `a`, `b` are both in
    -- `M ‚äó ((‚àè i ‚àà S, C i) √ó (‚àè i ‚àâ S, R i))`, and then by your earlier work we know
    -- that the map from this to `(‚àè i ‚àà S, M ‚äó C i) √ó (‚àè i ‚àâ S, M ‚äó R i)` is injective,
    -- and then by flatness the map from that to
    -- `Œ† ≥ (i : Œπ), [M ‚äó[A] R i, ‚Üë(Submodule.lTensor M (C i))]_[‚Ñ±]` is injective,
    -- and `a` and `b` have become equal after the composite of those two injections,
    -- so they are equal.
    -- have h_finite : ‚àÉ (S : Finset Œπ), S.toSet ‚àà ‚Ñ± ‚àß
    -- (‚àÄ x ‚àà {a, b}, ‚àÉ (f : Œπ ‚Üí A), Set.finite {i | f i ‚â† 0} ‚àß
    --  ‚àÄ i ‚àâ S, (TensorProduct.lift _ x : _) i ‚àà Submodule.lTensor M (C i)) := by
    --   sorry


    -- haveI {S: Set Œπ} {h: S ‚àà ‚Ñ±} : AddCommMonoid ((Œ† i ‚àà S, C i) √ó (Œ† i ‚àâ S, R i)) := sorry
    -- have : ‚àÉS ‚àà ‚Ñ±, a.val ‚àà (M ‚äó[A] ((Œ† i ‚àà S, C i) √ó (Œ† i ‚àâ S, R i))) ‚àß
    --   b.val ‚àà (M ‚äó[A] ((Œ† i ‚àà S, C i) √ó (Œ† i ‚àâ S, R i))) := sorry
    sorry,
  by
    intro y
    -- by definition `y ‚àà (‚àè i ‚àà S, ‚Üë(Submodule.lTensor M (C i))) √ó (‚àè i ‚àâ S, M ‚äó R i)`
    -- for some `S ‚àà ‚Ñ±`, and there's a surjection (in fact a bijection) from
    -- `(‚àè i ‚àà S, M ‚äó (C i)) √ó (‚àè i ‚àâ S, M ‚äó R i)` onto this, and then by your earlier
    -- work there's something in `M ‚äó ((‚àè i ‚àà S, C i) √ó (‚àè i ‚àâ S, R i))` which hits
    -- this, and the image of that thing in `M ‚äó[A] Œ† ≥ (i : Œπ), [R i, ‚Üë(C i)]_[‚Ñ±]`
    -- will do
    sorry‚ü©




end

section
variable (A K L B : Type*) [CommRing A] [CommRing B] [Algebra A B] [Field K] [Field L]
    [Algebra A K] [IsFractionRing A K] [Algebra B L] [IsDedekindDomain A]
    [Algebra K L] [Algebra A L] [IsScalarTower A B L] [IsScalarTower A K L]
    [IsIntegralClosure B A L] [FiniteDimensional K L] [Module.Finite A B]
    [IsDedekindDomain B] [IsFractionRing B L]

variable (M : Type*) [AddCommGroup M] [Module A M] [Module.FinitePresentation A M]
namespace IsDedekindDomain

open IsDedekindDomain HeightOneSpectrum
#check Module.DirectLimit

noncomputable instance : DecidableEq (HeightOneSpectrum A) :=
  Classical.typeDecidableEq (HeightOneSpectrum A)


noncomputable def f (S T : Finset (HeightOneSpectrum A)) (h : S ‚â§ T) :
  ((Œ† v : S, v.1.adicCompletion K) √ó
  (Œ† v : {v // v ‚àâ S}, (adicCompletionIntegers K v.1))) ‚Üí‚Çó[A]
  ((Œ† v : T, v.1.adicCompletion K) √ó
  (Œ† v : {v // v ‚àâ T}, (adicCompletionIntegers K v.1))) where
    toFun x := (fun v ‚Ü¶
      if h' : (v : HeightOneSpectrum A) ‚àà S then
        x.1 ‚ü®v, h'‚ü©
      else
        algebraMap _ _ (x.2 ‚ü®v, h'‚ü©),
     fun v ‚Ü¶ x.2 ‚ü®v, Set.notMem_subset h v.2‚ü©)
    map_add' x y := by
      simp only [Prod.fst_add, Pi.add_apply, Prod.snd_add, ValuationSubring.algebraMap_apply,
        AddMemClass.coe_add, Prod.mk_add_mk, Prod.mk.injEq]
      constructor
      ¬∑ ext v
        by_cases hv : (v : HeightOneSpectrum A) ‚àà S
        ¬∑ simp [hv]
        ¬∑ simp [hv]
      ¬∑ ext v
        simp only [AddMemClass.coe_add, Pi.add_apply]
    map_smul' r x := by
      simp only [Prod.smul_fst, Pi.smul_apply, Prod.smul_snd, ValuationSubring.algebraMap_apply,
        coe_smul_adicCompletionIntegers, RingHom.id_apply, Prod.smul_mk, Prod.mk.injEq]
      constructor
      ¬∑ ext v
        by_cases hv : (v : HeightOneSpectrum A) ‚àà S
        ¬∑ simp [hv]
        ¬∑ simp [hv]
      ¬∑ ext v
        simp only [coe_smul_adicCompletionIntegers, Pi.smul_apply]


noncomputable def direct_limit : (@Module.DirectLimit A _ (Finset (HeightOneSpectrum A)) _
  (fun S ‚Ü¶ ((Œ† v : S, v.1.adicCompletion K) √ó (Œ† v : (Set.compl (Finset.toSet S)),
  (adicCompletionIntegers K v.1)))) _ _ (f A K) _) ‚âÉ‚Çó[A] FiniteAdeleRing A K := by
  refine LinearEquiv.ofBijective (Module.DirectLimit.lift A (Finset (HeightOneSpectrum A))
    (fun S ‚Ü¶ ((Œ† v : S, v.1.adicCompletion K) √ó (Œ† v : (Set.compl (Finset.toSet S)),
   (adicCompletionIntegers K v.1)))) (f A K) ?_ ?_) ‚ü®?_, ?_‚ü©
  ¬∑ intro v
    simp only
    -- can rw as restricted product on princpal filter and go from there?
    sorry
  ¬∑ intro v w
    sorry
  ¬∑ apply Module.DirectLimit.lift_injective
    intro v

    sorry
  ¬∑
    sorry

end IsDedekindDomain


#exit



-- def G (S : Finset (HeightOneSpectrum A)):=
-- ((Œ† v : S, v.1.adicCompletion K) √ó (Œ† v : (Set.compl (Finset.toSet S)), (adicCompletionIntegers K v.1)))

-- #check G A K

-- noncomputable instance (S : Finset (HeightOneSpectrum A)) : AddCommGroup (G A K S) :=
--   Prod.instAddCommGroup

-- instance (S : Finset (HeightOneSpectrum A)) : Module A (G A K S) := by
--   sorry

def DirectLimit' :=
  @Module.DirectLimit A _ (Finset (HeightOneSpectrum A)) _
  (fun S ‚Ü¶ ((Œ† v : S, v.1.adicCompletion K) √ó (Œ† v : (Set.compl (Finset.toSet S)),
  (adicCompletionIntegers K v.1)))) _ _ (f A K) _

-- noncomputable def LHS (S : FiniteSubsets A) :=
--   M ‚äó[A] ((Œ† v : S.val, adicCompletion K v.1) √ó
--           (Œ† v : (Set.compl S.val), adicCompletionIntegers K v.1))

-- noncomputable def RHS (S : FiniteSubsets A) :=
--   (Œ† v : S.val, M ‚äó[A] adicCompletion K v.1) √ó
--   (Œ† v : (Set.compl S.val), M ‚äó[A] adicCompletionIntegers K v.1)

-- instance (S: FiniteSubsets A): AddCommMonoid (LHS A K M S) := by
--   dsimp [LHS]
--   exact TensorProduct.addCommMonoid

variable (iso : ‚àÄ S : FiniteSubsets A, (M ‚äó[A] ((Œ† v : S.val, adicCompletion K v.1) √ó
          (Œ† v : (Set.compl S.val), adicCompletionIntegers K v.1))) ‚âÉ‚Çó[A]
          ((Œ† v : S.val, M ‚äó[A] adicCompletion K v.1) √ó
  (Œ† v : (Set.compl S.val), M ‚äó[A] adicCompletionIntegers K v.1)))

let q : ‚Ñ§ := 1
def LHS_limit : Type* :=
  lim (fun S : FiniteSubsets => (M ‚äó[A] ((Œ† v : S.val, adicCompletion K v.1) √ó
          (Œ† v : (Set.compl S.val), adicCompletionIntegers K v.1))))



end IsDedekindDomain
