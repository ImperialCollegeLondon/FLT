

/-
-- You can still add more lemmas to it later if needed:
theorem my_custom_scalar_lemma (x : Nat) : x * 1 = x := mul_one x
attribute [scalar_prod_simp] my_custom_scalar_lemma
- /

initialize registerSimpAttr `scalar_prod_simp "A flexible way to bundle \
  a collection of simp lemmas under a single identifier "
-/

open Lean Meta Tactics

-- Define your function and some properties
def my_func (x : Nat) := x + x

@[simp]
theorem my_func_zero : my_func 0 = 0 := rfl

-- A custom simp set for specific lemmas
register_simp_attr my_rules

@[my_rules]
theorem my_func_add (x y : Nat) : my_func (x + y) = my_func x + my_func y := by
  simp [my_func]
  ring

-- An example of using the custom simp set
example (a b : Nat) : my_func (a + b) = my_func a + my_func b := by
  simp [my_func_add]
/--
-- You can also tag lemmas when you define them
@[scalar_prod_simp]
lemma mulEquivHaarChar_id {G : Type*} [Group G] [TopologicalSpace G]
    [LocallyCompactSpace G] [MeasurableSpace G] [BorelSpace G] [IsTopologicalGroup G] :
    mulEquivHaarChar (ContinuousMulEquiv.refl G) = 1 :=
  mulEquivHaarChar_refl

-- Tag multiple lemmas at once after definition
attribute [scalar_prod_simp]
  mulEquivHaarChar_trans
  mulEquivHaarChar_refl
  mulEquivHaarChar_eq_one_of_compactSpace

-- Example 1: Basic usage in a proof
example {G : Type*} [Group G] [TopologicalSpace G] [LocallyCompactSpace G]
    [MeasurableSpace G] [BorelSpace G] [IsTopologicalGroup G]
    (φ : G ≃ₜ* G) :
    mulEquivHaarChar φ * 1 = mulEquivHaarChar φ := by
  simp only with scalar_prod_simp

-- Example 2: Using with additional lemmas
example {G : Type*} [Group G] [TopologicalSpace G] [LocallyCompactSpace G]
    [MeasurableSpace G] [BorelSpace G] [IsTopologicalGroup G]
    (φ ψ : G ≃ₜ* G) :
    mulEquivHaarChar (φ.trans ψ) * mulEquivHaarChar (ContinuousMulEquiv.refl G) =
    mulEquivHaarChar ψ * mulEquivHaarChar φ := by
  simp only with scalar_prod_simp
  -- or combine with other simp sets/lemmas
  -- simp only [some_other_lemma] with scalar_prod_simp

-- Example 3: More complex proof using the attribute
example {G H : Type*}
    [Group G] [TopologicalSpace G] [LocallyCompactSpace G]
    [MeasurableSpace G] [BorelSpace G] [IsTopologicalGroup G]
    [Group H] [TopologicalSpace H] [LocallyCompactSpace H]
    [MeasurableSpace H] [BorelSpace H] [IsTopologicalGroup H]
    (φ : G ≃ₜ* G) (ψ : H ≃ₜ* H) (χ : G ≃ₜ* G) :
    mulEquivHaarChar (φ.trans χ) * mulEquivHaarChar ψ * 1 =
    mulEquivHaarChar χ * mulEquivHaarChar φ * mulEquivHaarChar ψ := by
  -- First simplify with our custom simp set
  simp only with scalar_prod_simp
  -- The proof might need additional steps
  ring

-- Example 4: Using in term mode with simp
def simplifiedHaarChar {G : Type*} [Group G] [TopologicalSpace G]
    [LocallyCompactSpace G] [MeasurableSpace G] [BorelSpace G] [IsTopologicalGroup G]
    (φ : G ≃ₜ* G) : ℝ≥0 :=
  -- Use simp with the attribute in term mode
  mulEquivHaarChar φ * 1 |>.simp (config := {}) (simpAttr := #[`scalar_prod_simp])
-- Example 5: Conditional attribute tagging
section CompactCase
variable [CompactSpace G]
-- Tag lemmas conditionally for compact spaces
attribute [local scalar_prod_simp] mulEquivHaarChar_eq_one_of_compactSpace

example {G : Type*} [Group G] [TopologicalSpace G] [LocallyCompactSpace G]
    [MeasurableSpace G] [BorelSpace G] [IsTopologicalGroup G] [CompactSpace G]
    (φ : G ≃ₜ* G) :
    mulEquivHaarChar φ = 1 := by
  simp only with scalar_prod_simp

end CompactCase

-- Example 6: Creating derived simp sets
initialize registerSimpAttr `scalar_prod_simp_aggressive
  "Aggressive simplification for scalar products (includes AC lemmas)"
-- Include everything from scalar_prod_simp plus more
attribute [scalar_prod_simp_aggressive]
  mul_left_comm
  mul_right_comm
  -- all lemmas from scalar_prod_simp are NOT automatically included,
  -- you need to tag them again
  mulEquivHaarChar_trans
  mulEquivHaarChar_refl
  one_mul
  mul_one

-- Example 7: Using multiple simp attributes together
example {G : Type*} [Group G] [TopologicalSpace G] [LocallyCompactSpace G]
    [MeasurableSpace G] [BorelSpace G] [IsTopologicalGroup G]
    (φ ψ χ : G ≃ₜ* G) :
    mulEquivHaarChar ψ * mulEquivHaarChar φ * mulEquivHaarChar χ =
    mulEquivHaarChar φ * mulEquivHaarChar ψ * mulEquivHaarChar χ := by
  simp only with scalar_prod_simp, scalar_prod_simp_aggressive

-- Example 8: Removing lemmas from the simp set
attribute [-scalar_prod_simp] mul_comm  -- Remove mul_comm from the set

-- Example 9: Checking what's in your simp set (for debugging)
#check @scalar_prod_simp.lemmas  -- Shows the lemmas in the set

-- Example 10: Pattern for organizing simp attributes in a large project
namespace HaarCharSimp

-- Core simplification lemmas
initialize registerSimpAttr `haar_core

-- Lemmas specific to products
initialize registerSimpAttr `haar_prod

-- Lemmas for the compact case
initialize registerSimpAttr `haar_compact

-- Combine all
initialize registerSimpAttr `haar_all

end HaarCharSimp

-- Tag lemmas appropriately
attribute [HaarCharSimp.haar_core]
  mulEquivHaarChar_trans
  mulEquivHaarChar_refl

attribute [HaarCharSimp.haar_prod]
  mulEquivHaarChar_prodCongr

attribute [HaarCharSimp.haar_compact]
  mulEquivHaarChar_eq_one_of_compactSpace

-- Use specialized sets
example {G : Type*} [Group G] [TopologicalSpace G] [LocallyCompactSpace G]
    [MeasurableSpace G] [BorelSpace G] [IsTopologicalGroup G] [CompactSpace G]
    (φ : G ≃ₜ* G) : mulEquivHaarChar φ = 1 := by
  simp only with HaarCharSimp.haar_compact, HaarCharSimp.haar_core

-/

/- map_haar_pi -/
calc Measure.map T μ_haar_pi
  _ = Measure.map T (Measure.map me.symm (μ_haar_i₀.prod μ_haar_pi')) := by rw [← measure_eq]
  _ = Measure.map (T ∘ me.symm) (μ_haar_i₀.prod μ_haar_pi') := by
    rw [← Measure.map_map me.symm.measurable T.continuous.measurable]
  _ = Measure.map (me.symm ∘ C) (μ_haar_i₀.prod μ_haar_pi') := by
    congr 1
    ext ⟨x, g⟩
    simp only [Function.comp_apply]
    have : T (me.symm ⟨x, g⟩) = me.symm (C ⟨x, g⟩) := by
      rw [transform_conj]
      simp [ContinuousMulEquiv.trans_apply]
    exact this
  _ = Measure.map me.symm (Measure.map C (μ_haar_i₀.prod μ_haar_pi')) := by
    rw [Measure.map_map C.continuous.measurable me.symm.measurable]
  _ = Measure.map me.symm ((Measure.map T_i₀ μ_haar_i₀).prod (Measure.map T_pi' μ_haar_pi')) := by
    rw [Measure.map_prod_map T_i₀.continuous.measurable T_pi'.continuous.measurable]
  _ = Measure.map me.symm ((mulEquivHaarChar T_i₀ • μ_haar_i₀).prod ((∏ i', mulEquivHaarChar (ψ' i')) • μ_haar_pi')) := by
    congr 1
    constructor
    · exact mulEquivHaarChar_map μ_haar_i₀ T_i₀
    · exact ih_ι'
  _ = Measure.map me.symm ((mulEquivHaarChar T_i₀ * ∏ i', mulEquivHaarChar (ψ' i')) • (μ_haar_i₀.prod μ_haar_pi')) := by
    rw [Measure.prod_smul]
  _ = (mulEquivHaarChar T_i₀ * ∏ i', mulEquivHaarChar (ψ' i')) • Measure.map me.symm (μ_haar_i₀.prod μ_haar_pi') := by
    rw [Measure.map_smul]
  _ = (mulEquivHaarChar (ψ i₀) * ∏ i', mulEquivHaarChar (ψ (i' : ι))) • μ_haar_pi := by
    simp only [T_i₀, ψ']
    rw [measure_eq]
  _ = (∏ i : ι, mulEquivHaarChar (ψ i)) • μ_haar_pi := by
    rw [← h_prod_decomp]
